<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mesh Network Demonstration</title>
    <style>
      :root {
        /* Inland Northwest inspired color palette */
        --bg-color: #f5f3ed;
        --client-color: #4a9fc9;
        --repeater-color: #2d5e82;
        --message-color: #d97762;
        --flood-color: #e6ad3f;
        --text-color: #333333;
        --button-bg: #4a9fc9;
        --button-hover: #2d5e82;
        --button-text: #ffffff;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu,
          Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        background-color: #ffffff;
        color: var(--text-color);
      }

      .hero-section {
        position: relative;
        width: 100%;
        height: 30vh;
        min-height: 250px;
        background-color: var(--bg-color);
        overflow: hidden;
      }

      .hero-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 2;
        padding: 1rem;
      }

      .hero-text-background {
        background-color: rgba(0, 0, 0, 0.6);
        padding: 1.5rem 2rem;
        border-radius: 5px;
        max-width: 90%;
        text-align: center;
      }

      .hero-title {
        font-size: 2.5rem;
        font-weight: 700;
        margin-bottom: 1rem;
        color: white;
      }

      .hero-description {
        font-size: 1.2rem;
        max-width: 600px;
        color: white;
      }

      #mesh-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      .fallback-image {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        text-align: center;
        color: var(--text-color);
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 0.6rem;
        padding: 1rem;
        max-width: 1200px;
        margin: 0 auto;
      }

      .controls button {
        background-color: var(--button-bg);
        color: var(--button-text);
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 500;
        transition: background-color 0.2s;
        display: flex;
        align-items: center;
        gap: 0.4rem;
        touch-action: manipulation; /* disables double-tap zoom */
      }

      .controls button .icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
      }

      .controls button:hover {
        background-color: var(--button-hover);
      }

      .icon {
        display: inline-block;
        width: 16px;
        height: 16px;
        position: relative;
      }

      @media (max-width: 768px) {
        .hero-title {
          font-size: 1.8rem;
        }

        .hero-description {
          font-size: 1rem;
        }

        .controls {
          justify-content: center;
        }

        .controls button {
          font-size: 0.8rem;
          min-width: 130px;
          padding: 0.4rem 0.8rem;
        }
      }
    </style>
  </head>
  <body>
    <section class="hero-section">
      <div class="hero-overlay">
        <div class="hero-text-background">
          <h1 class="hero-title">Mesh Network Communication</h1>
          <p class="hero-description">
            Visualizing how messages propagate across a distributed network of
            client and repeater nodes.
          </p>
        </div>
      </div>
      <canvas id="mesh-canvas"></canvas>
      <noscript>
        <div class="fallback-image">
          <div>
            <h2>Mesh Network Visualization</h2>
            <p>JavaScript is required to view the mesh network animation.</p>
          </div>
        </div>
      </noscript>
    </section>

    <div class="controls" id="controls-container"></div>

    <script>
      (() => {
        // --- CONSTANTS ---

        const ROOT_STYLES = getComputedStyle(document.documentElement);

        const NODE_TYPES = { CLIENT: "client", REPEATER: "repeater" };

        const DEFAULT_NODE_CONFIGS = {
          [NODE_TYPES.CLIENT]: {
            count: 25,
            mobileCountFactor: 0.6,
            size: 15,
            radius: 12,
            range: 200,
            rangeVariance: 30,
            useGrid: false,
            postPlacement: ensureClientConnectivity,
            color: ROOT_STYLES.getPropertyValue("--client-color").trim(),
          },
          [NODE_TYPES.REPEATER]: {
            count: 10,
            mobileCountFactor: 0.4,
            size: 25,
            radius: 20,
            range: 300,
            rangeVariance: 50,
            useGrid: true,
            color: ROOT_STYLES.getPropertyValue("--repeater-color").trim(),
          },
        };

        const PLACEMENT_ATTEMPTS_MAX = 30;

        const MESSAGE_CONFIG = {
          types: { DIRECT: "direct", FLOOD: "flood" },
          size: 7,
          speed: 320, // pixels per second
          maxHops: 5,
          autoSend: {
            delay: 1200, // milliseconds
            delayVariance: 500, // milliseconds
            batchSize: 4, // messages per interval
          },
          color: ROOT_STYLES.getPropertyValue("--message-color").trim(),
        };

        // Animation properties
        const TARGET_FPS = isMobileDevice() ? 40 : 60;
        const MIN_FRAME_DELAY = 1000 / TARGET_FPS;

        const SCALE_SPRING = 0.1; // spring stiffness
        const SCALE_DAMPING = 0.8; // friction resistance

        const FLOOD_EXPANSION_SPEED = 160; // pixels per second
        const DISAPPEARANCE_SPEED = 0.6; // seconds

        const BUTTON_CONFIGS = [
          {
            id: "send-message",
            icon: "→",
            label: "Send Message",
            action: () => {
              sendMessage();
              setTimeout(sendMessage, 150);
              setTimeout(sendMessage, 300);
            },
          },
          {
            id: "send-flood",
            icon: "❉",
            label: "Send Flood",
            action: () => sendFlood(),
          },
          {
            id: "add-client",
            icon: "＋",
            label: "Add Client",
            action: () => addNode(NODE_TYPES.CLIENT),
          },
          {
            id: "add-repeater",
            icon: "⊕",
            label: "Add Repeater",
            action: () => addNode(NODE_TYPES.REPEATER),
          },
          {
            id: "toggle-pause",
            icon: { pause: "❚❚", resume: "▶" },
            label: { pause: "Pause", resume: "Resume" },
            action: () => togglePause(),
          },
          {
            id: "reset",
            icon: "↻",
            label: "Reset",
            action: () => resetNetwork(),
          },
        ];

        // --- STATE VARIABLES ---

        let canvas;
        let ctx;
        let dpr = window.devicePixelRatio || 1;
        let resizeTimeout;
        let nodes = [];
        let messages = [];
        let floodRings = [];
        let processedFloodIds = new Set();
        let animationRunning = true;
        let animationFrame = null;
        let pauseBtn;
        let baseWidth, baseHeight;
        let minNodeDistance;
        let scaleFactor = 1;
        let scaleVelocity = 0;
        let targetScaleFactor = 1;
        let initialLayoutDone = false;
        let lastFrameTime = 0;
        let autoSendTimestamp = Date.now();
        let autoSendDelay = MESSAGE_CONFIG.autoSend.delay;

        // --- UTILITY FUNCTIONS ---

        function adjustColorBrightness(hex, percent) {
          let r = parseInt(hex.substring(1, 3), 16);
          let g = parseInt(hex.substring(3, 5), 16);
          let b = parseInt(hex.substring(5, 7), 16);

          r = Math.max(0, Math.min(255, r + percent));
          g = Math.max(0, Math.min(255, g + percent));
          b = Math.max(0, Math.min(255, b + percent));

          // Convert back to hex
          return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
        }

        function generateId() {
          return Math.random().toString(36).substr(2, 9);
        }

        function getDistance({ x: x1, y: y1 }, { x: x2, y: y2 }) {
          return Math.hypot(x2 - x1, y2 - y1);
        }

        function getRandomInt(min, max) {
          return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function isMobileDevice() {
          return (
            window.innerWidth <= 768 ||
            (navigator.maxTouchPoints > 0 &&
              /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                navigator.userAgent,
              ))
          );
        }

        // --- CORE SIMULATION FUNCTIONS ---

        function createNode(type) {
          const config = getNodeConfig(type);
          if (!config) return null;

          const { radius, range, rangeVariance, size } = config;

          const node = {
            id: generateId(),
            type,
            x: getRandomInt(radius * 2, baseWidth - radius * 2),
            y: getRandomInt(radius * 2, baseHeight - radius * 2),
            radius,
            range: range + getRandomInt(-rangeVariance, rangeVariance),
            size,
          };

          return node;
        }

        function isTooCloseToOtherNodes(x, y, excludeId = null) {
          return nodes.some(
            (node) =>
              (excludeId === null || node.id !== excludeId) &&
              getDistance({ x, y }, node) < minNodeDistance,
          );
        }

        const placeNodes = (type) => {
          const config = getNodeConfig(type);
          if (!config) return;

          const { count, useGrid, postPlacement } = config;

          let gridCols, gridRows, cellWidth, cellHeight;
          if (useGrid) {
            gridCols = Math.ceil(Math.sqrt(count));
            gridRows = Math.ceil(count / gridCols);
            cellWidth = baseWidth / gridCols;
            cellHeight = baseHeight / gridRows;
          }

          let placed = 0;
          for (let i = 0; i < count; i++) {
            const node = createNode(type);
            let attempts = 0;
            let validPlacement = false;

            while (!validPlacement && attempts < PLACEMENT_ATTEMPTS_MAX) {
              if (useGrid) {
                const row = Math.floor(placed / gridCols);
                const col = placed % gridCols;
                node.x =
                  col * cellWidth + cellWidth * (0.25 + Math.random() * 0.5);
                node.y =
                  row * cellHeight + cellHeight * (0.25 + Math.random() * 0.5);
              } else {
                node.x = getRandomInt(
                  node.radius * 2,
                  baseWidth - node.radius * 2,
                );
                node.y = getRandomInt(
                  node.radius * 2,
                  baseHeight - node.radius * 2,
                );
              }

              validPlacement = !isTooCloseToOtherNodes(node.x, node.y);
              attempts++;
            }

            nodes.push(node);
            placed++;
          }

          if (postPlacement) {
            postPlacement();
          }
        };

        function getNodeConfig(type) {
          const config = NODE_CONFIGS[type];
          if (!config) {
            console.error(`Unknown node type: ${type}`);
            return null;
          }
          return config;
        }

        // Ensure every client can communicate with at least one repeater
        function ensureClientConnectivity() {
          const repeaters = nodes.filter(
            (node) => node.type === NODE_TYPES.REPEATER,
          );

          nodes.forEach((node) => {
            if (node.type === NODE_TYPES.CLIENT) {
              // Check if this client can reach any repeater
              const canReachRepeater = repeaters.some(
                (repeater) =>
                  getDistance(node, repeater) <=
                  Math.max(node.range, repeater.range),
              );

              if (!canReachRepeater && repeaters.length > 0) {
                // Find the closest repeater
                repeaters.sort(
                  (a, b) => getDistance(node, a) - getDistance(node, b),
                );
                const closest = repeaters[0];

                // Calculate a position that's within range but not too close
                const distance = getDistance(node, closest);
                const angle = Math.atan2(
                  node.y - closest.y,
                  node.x - closest.x,
                );
                const targetDistance =
                  Math.min(closest.range, node.range) * 0.9; // 90% of the smaller range

                let newX = closest.x + Math.cos(angle) * targetDistance;
                let newY = closest.y + Math.sin(angle) * targetDistance;

                // Make sure it's within canvas bounds
                newX = Math.max(
                  node.radius * 2,
                  Math.min(newX, baseWidth - node.radius * 2),
                );
                newY = Math.max(
                  node.radius * 2,
                  Math.min(newY, baseHeight - node.radius * 2),
                );

                node.x = newX;
                node.y = newY;
              }
            }
          });
        }

        function findPathThroughRepeaters(
          route,
          currentNode,
          targetNode,
          hopCount,
        ) {
          // Base case: too many hops
          if (hopCount >= MESSAGE_CONFIG.maxHops) {
            return false;
          }

          // Check if current node can reach target directly
          if (getDistance(currentNode, targetNode) <= currentNode.range) {
            route.push({ id: targetNode.id, x: targetNode.x, y: targetNode.y });
            return true;
          }

          // Get all repeaters in range of current node
          const repeaters = nodes.filter(
            (node) =>
              node.type === NODE_TYPES.REPEATER &&
              node.id !== currentNode.id &&
              getDistance(currentNode, node) <= currentNode.range &&
              !route.some((hop) => hop.id === node.id), // Avoid loops
          );

          // Sort repeaters by distance to target
          repeaters.sort(
            (a, b) => getDistance(a, targetNode) - getDistance(b, targetNode),
          );

          // Try each repeater
          for (const repeater of repeaters) {
            route.push({ id: repeater.id, x: repeater.x, y: repeater.y });

            if (
              findPathThroughRepeaters(
                route,
                repeater,
                targetNode,
                hopCount + 1,
              )
            ) {
              return true;
            }

            // If this path didn't work, backtrack
            route.pop();
          }

          return false;
        }

        // Find a route from source to target through repeaters if needed
        function findRoute(sourceNode, targetNode) {
          const route = [
            { id: sourceNode.id, x: sourceNode.x, y: sourceNode.y },
          ];

          // Check if direct path is available
          if (getDistance(sourceNode, targetNode) <= sourceNode.range) {
            route.push({ id: targetNode.id, x: targetNode.x, y: targetNode.y });
            return route;
          }

          // If not direct, try multi-hop routing through repeaters
          const foundPath = findPathThroughRepeaters(
            route,
            sourceNode,
            targetNode,
            0,
          );

          if (!foundPath) {
            // No valid path found, return the incomplete route
            return route;
          }

          return route;
        }

        // Create a direct message
        function createDirectMessage(sourceNode, targetNode) {
          // Find the best route that respects the range limitations
          const route = findRoute(sourceNode, targetNode);

          // If route only has source or is incomplete, this means no valid path exists
          if (
            route.length <= 1 ||
            route[route.length - 1].id !== targetNode.id
          ) {
            return null;
          }

          return {
            id: generateId(),
            type: MESSAGE_CONFIG.types.DIRECT,
            sourceId: sourceNode.id,
            targetId: targetNode.id,
            x: sourceNode.x,
            y: sourceNode.y,
            size: MESSAGE_CONFIG.size,
            route: route,
            currentHopIndex: 0,
            delivered: false,
            progress: 0, // Used for drawing a trail
            trail: [], // Store previous positions for trail effect
            trail_max_length: 10, // Max number of positions to store
          };
        }

        // Create a flood ring (visualization for flood messages)
        function createFloodRing(sourceNode, originalFloodId = null) {
          const floodId = originalFloodId || generateId();
          return {
            id: generateId(),
            floodId: floodId, // Unique ID for this flood event
            sourceId: sourceNode.id,
            x: sourceNode.x,
            y: sourceNode.y,
            radius: 0,
            maxRadius: sourceNode.range,
            expandSpeed: FLOOD_EXPANSION_SPEED,
            opacity: 0.7,
            affectedNodes: new Set(), // Track which nodes have been affected by this flood
          };
        }

        const addNode = (type) => {
          const node = createNode(type);
          let validPlacement = false;
          let attempts = 0;

          while (!validPlacement && attempts < 30) {
            node.x = getRandomInt(node.radius * 2, baseWidth - node.radius * 2);
            node.y = getRandomInt(
              node.radius * 2,
              baseHeight - node.radius * 2,
            );
            validPlacement = !isTooCloseToOtherNodes(node.x, node.y);
            attempts++;
          }

          nodes.push(node);

          if (type === NODE_TYPES.CLIENT) {
            setTimeout(() => sendMessage(node.id), 300);
          }
        };

        const sendMessage = (sourceNodeId = null) => {
          // Choose random client if none specified
          if (!sourceNodeId) {
            const clientNodes = nodes.filter(
              (node) => node.type === NODE_TYPES.CLIENT,
            );
            if (clientNodes.length === 0) return;
            sourceNodeId =
              clientNodes[Math.floor(Math.random() * clientNodes.length)].id;
          }

          const sourceNode = nodes.find((node) => node.id === sourceNodeId);
          if (!sourceNode) return;

          // First try to find clients that are within direct range
          const directReachable = nodes.filter(
            (node) =>
              node.id !== sourceNodeId &&
              node.type === NODE_TYPES.CLIENT &&
              getDistance(sourceNode, node) <= sourceNode.range,
          );

          // Then find clients that require repeaters
          const needRepeaters = nodes.filter(
            (node) =>
              node.id !== sourceNodeId &&
              node.type === NODE_TYPES.CLIENT &&
              getDistance(sourceNode, node) > sourceNode.range,
          );

          let targetNode;
          let message = null;

          // Try to find a message that can be delivered
          // First try clients that need multiple hops (more interesting visually)
          if (needRepeaters.length > 0) {
            // 80% chance to pick a target that needs repeaters when available
            if (Math.random() < 0.8) {
              // Try a few targets that require repeaters
              for (let attempts = 0; attempts < 3; attempts++) {
                targetNode =
                  needRepeaters[
                    Math.floor(Math.random() * needRepeaters.length)
                  ];
                message = createDirectMessage(sourceNode, targetNode);

                // Prefer routes with more hops
                if (message && message.route.length > 3) {
                  break; // Great! A multi-hop route
                } else if (message && message.route.length > 2) {
                  // Single repeater - keep looking or settle with 50% chance
                  if (Math.random() < 0.5) break;
                }
              }
            }
          }

          // If no multi-hop message created and there are directly reachable clients, try those
          if (!message && directReachable.length > 0) {
            targetNode =
              directReachable[
                Math.floor(Math.random() * directReachable.length)
              ];
            message = createDirectMessage(sourceNode, targetNode);
          }
          // If still no message but we have clients requiring repeaters, use the first valid route found
          else if (!message && needRepeaters.length > 0) {
            for (let i = 0; i < needRepeaters.length; i++) {
              targetNode = needRepeaters[i];
              message = createDirectMessage(sourceNode, targetNode);
              if (message) break;
            }
          }

          // If we found a valid message, add it
          if (message) {
            messages.push(message);
          }
        };

        // Send a flood message
        const sendFlood = (sourceNodeId = null) => {
          // Choose random client if none specified
          if (!sourceNodeId) {
            const clientNodes = nodes.filter(
              (node) => node.type === NODE_TYPES.CLIENT,
            );
            if (clientNodes.length === 0) return;
            sourceNodeId =
              clientNodes[Math.floor(Math.random() * clientNodes.length)].id;
          }

          const sourceNode = nodes.find((node) => node.id === sourceNodeId);
          if (!sourceNode) return;

          // Create a flood ring with a unique flood ID
          const floodId = generateId();
          const ring = createFloodRing(sourceNode, floodId);
          processedFloodIds.add(floodId + "-" + sourceNode.id); // Mark this node as having processed this flood

          floodRings.push(ring);
        };

        const resetNetwork = () => {
          cancelAnimationFrame(animationFrame);
          initNetwork();
          animate(performance.now());
          updatePauseButton();
        };

        // Update node sizes based on device
        const updateNodeSizes = () => {
          const sizeFactor = isMobileDevice() ? 0.5 : 1;

          NODE_CONFIGS = {};

          Object.entries(DEFAULT_NODE_CONFIGS).forEach(([type, def]) => {
            const countFactor = isMobileDevice() ? def.mobileCountFactor : 1;

            NODE_CONFIGS[type] = {
              ...def,
              count: Math.floor(def.count * countFactor),
              size: def.size * sizeFactor,
              radius: def.radius * sizeFactor,
              range: def.range * sizeFactor,
              rangeVariance: def.rangeVariance * sizeFactor,
              borderColor: adjustColorBrightness(def.color, -20),
            };
          });

          // Adjust minimum node distance
          minNodeDistance = isMobileDevice() ? 40 : 70;
        };

        const initNetwork = () => {
          // Reset state
          nodes = [];
          messages = [];
          floodRings = [];
          processedFloodIds = new Set();

          // Place well-distributed repeaters first
          placeNodes(NODE_TYPES.REPEATER);
          placeNodes(NODE_TYPES.CLIENT);

          // Send a batch of initial messages
          setTimeout(() => {
            for (let i = 0; i < 5; i++) {
              setTimeout(() => {
                if (i % 20 === 0) {
                  // 5% chance for flood (1 out of 20)
                  sendFlood();
                } else {
                  sendMessage();
                }
              }, i * 300);
            }
          }, 500);
        };

        // --- DRAWING FUNCTIONS ---

        // Draw transmission range for nodes
        const drawNodeRanges = () => {
          nodes.forEach((node) => {
            ctx.beginPath();
            ctx.arc(node.x, node.y, node.range, 0, Math.PI * 2);

            // Different colors for client and repeater ranges
            if (node.type === NODE_TYPES.CLIENT) {
              ctx.strokeStyle = "rgba(74, 159, 201, 0.1)";
            } else {
              ctx.strokeStyle = "rgba(45, 94, 130, 0.1)";
            }

            ctx.lineWidth = 1;
            ctx.stroke();
          });
        };

        // Draw flood rings
        const drawFloodRings = () => {
          floodRings.forEach((ring) => {
            ctx.beginPath();
            ctx.arc(ring.x, ring.y, ring.radius, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(230, 173, 63, ${ring.opacity})`;
            ctx.lineWidth = 2;
            ctx.stroke();
          });
        };

        // Draw message routes (faint lines showing the path)
        const drawMessageRoutes = () => {
          messages.forEach((message) => {
            if (message.type !== MESSAGE_CONFIG.types.DIRECT) return;
            if (message.delivered) return; // Don't show routes for delivered messages

            // Draw the complete route
            ctx.beginPath();
            ctx.setLineDash([3, 3]);
            ctx.strokeStyle = "rgba(217, 119, 98, 0.4)";
            ctx.lineWidth = 1;

            const route = message.route;
            ctx.moveTo(route[0].x, route[0].y);

            for (let i = 1; i < route.length; i++) {
              ctx.lineTo(route[i].x, route[i].y);
            }

            ctx.stroke();
            ctx.setLineDash([]); // Reset line dash
          });
        };

        // Draw trails behind messages
        const drawMessageTrails = () => {
          messages.forEach((message) => {
            if (message.type !== MESSAGE_CONFIG.types.DIRECT) return;
            if (!message.trail || message.trail.length < 2) return;

            ctx.beginPath();
            const trail = message.trail;
            ctx.moveTo(trail[0].x, trail[0].y);

            for (let i = 1; i < trail.length; i++) {
              ctx.lineTo(trail[i].x, trail[i].y);
            }

            // Fade based on how old the last point is
            const now = performance.now();
            const oldest = trail[0].time;
            const newest = trail[trail.length - 1].time;
            const alpha = Math.min(1, (now - oldest) / (newest - oldest + 1));

            const gradient = ctx.createLinearGradient(
              trail[0].x,
              trail[0].y,
              trail[trail.length - 1].x,
              trail[trail.length - 1].y,
            );
            gradient.addColorStop(0, "rgba(217, 119, 98, 0)");
            gradient.addColorStop(1, "rgba(217, 119, 98, 0.5)");

            ctx.strokeStyle = gradient;
            ctx.lineWidth = 3;
            ctx.stroke();
          });
        };

        const drawHexagon = ({ x, y, size, fillColor, borderColor }) => {
          const numberOfSides = 6;
          const a = (Math.PI * 2) / numberOfSides;

          ctx.beginPath();
          ctx.moveTo(
            x + size * Math.cos(Math.PI / 2),
            y + size * Math.sin(Math.PI / 2),
          );

          for (let i = 1; i <= numberOfSides; i++) {
            const angle = Math.PI / 2 + a * i;
            ctx.lineTo(x + size * Math.cos(angle), y + size * Math.sin(angle));
          }

          ctx.closePath();
          ctx.fillStyle = fillColor;
          ctx.fill();
          ctx.strokeStyle = borderColor;
          ctx.lineWidth = 1.5;
          ctx.stroke();
        };

        const drawNodes = () => {
          nodes.forEach((node) => {
            const config = getNodeConfig(node.type);
            if (!config) return;

            drawHexagon({
              x: node.x,
              y: node.y,
              size: node.size,
              fillColor: config.color,
              borderColor: config.borderColor,
            });
          });
        };

        const drawMessages = () => {
          messages.forEach((message) => {
            if (message.type !== MESSAGE_CONFIG.types.DIRECT) return;

            const color = MESSAGE_CONFIG.color;

            if (message.delivered) {
              // Draw delivery effect (growing pulse)
              const easedProgress = Math.pow(message.progress, 0.5);

              ctx.beginPath();
              ctx.arc(
                message.x,
                message.y,
                message.size + easedProgress * 15,
                0,
                Math.PI * 2,
              );
              ctx.fillStyle = `rgba(217, 119, 98, ${1 - easedProgress})`;
              ctx.fill();
            }

            // Draw message (circle)
            ctx.beginPath();
            ctx.arc(message.x, message.y, message.size, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();

            // Add a white border to make messages more visible
            ctx.strokeStyle = "rgba(255, 255, 255, 0.6)";
            ctx.lineWidth = 2;
            ctx.stroke();
          });
        };

        // Draw all elements on canvas
        const draw = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const scaledWidth = canvas.width / dpr;
          const scaledHeight = canvas.height / dpr;

          // Calculate the center offset to position the network in the middle
          const offsetX = (scaledWidth - baseWidth * scaleFactor) / 2;
          const offsetY = (scaledHeight - baseHeight * scaleFactor) / 2;

          ctx.save();
          ctx.scale(scaleFactor, scaleFactor);
          ctx.translate(Math.max(0, offsetX), Math.max(0, offsetY));

          drawNodeRanges();
          drawFloodRings();
          drawMessageRoutes();
          drawMessageTrails();
          drawNodes();
          drawMessages();

          // Restore original scaling
          ctx.restore();
        };

        // --- SIMULATION UPDATE FUNCTIONS ---

        const updateMessages = (deltaTime) => {
          for (let i = messages.length - 1; i >= 0; i--) {
            const message = messages[i];
            if (message.type !== MESSAGE_CONFIG.types.DIRECT) continue;

            if (message.delivered) {
              message.progress += deltaTime / DISAPPEARANCE_SPEED;
              if (message.progress >= 1) {
                messages.splice(i, 1);
              }
              continue;
            }

            // Get current and next points in the route
            const currentHopIndex = message.currentHopIndex;
            const nextHopIndex = currentHopIndex + 1;

            // Check if we've reached the end of the route
            if (nextHopIndex >= message.route.length) {
              message.delivered = true;
              continue;
            }

            const currentPoint = message.route[currentHopIndex];
            const nextPoint = message.route[nextHopIndex];

            const now = performance.now();

            // Add current position to trail
            message.trail.push({ x: message.x, y: message.y, time: now });

            // cap trail by time
            const trailDuration = 0.15 * 1000; // seconds worth of trail

            message.trail = message.trail.filter(
              (p) => now - p.time <= trailDuration,
            );

            // Calculate distance to next hop
            const dx = nextPoint.x - message.x;
            const dy = nextPoint.y - message.y;
            const distanceToNext = Math.sqrt(dx * dx + dy * dy);

            const distance = MESSAGE_CONFIG.speed * deltaTime;

            if (distance >= distanceToNext) {
              // Reached next hop
              message.x = nextPoint.x;
              message.y = nextPoint.y;
              message.currentHopIndex = nextHopIndex;

              message.trail = [];

              // If we've reached the final destination, mark as delivered
              if (nextHopIndex === message.route.length - 1) {
                message.delivered = true;
                message.progress = 0;
                continue;
              }
            } else {
              // Move towards next hop
              message.x += (dx / distanceToNext) * distance;
              message.y += (dy / distanceToNext) * distance;
            }
          }
        };

        const updateFloods = (deltaTime) => {
          for (let i = floodRings.length - 1; i >= 0; i--) {
            const ring = floodRings[i];

            // Expand the ring
            ring.radius += ring.expandSpeed * deltaTime;
            ring.opacity = 0.7 * (1 - ring.radius / ring.maxRadius);

            // Check if any nodes are hit by the expanding ring
            nodes.forEach((node) => {
              // Skip the source node
              if (node.id === ring.sourceId) return;

              // If this node has already processed this flood ID, skip it
              if (processedFloodIds.has(ring.floodId + "-" + node.id)) return;

              // Check if the node is hit by the expanding ring
              const distance = getDistance({ x: ring.x, y: ring.y }, node);
              const isNodeHit = Math.abs(distance - ring.radius) < node.radius;

              if (isNodeHit) {
                // Mark this node as having received this flood ID
                processedFloodIds.add(ring.floodId + "-" + node.id);

                // If this is a repeater, create a new flood ring with same flood ID
                if (node.type === NODE_TYPES.REPEATER) {
                  const newRing = createFloodRing(node, ring.floodId);
                  floodRings.push(newRing);
                }
              }
            });

            // Remove the ring if it's reached its maximum radius
            if (ring.radius >= ring.maxRadius) {
              floodRings.splice(i, 1);
            }
          }
        };

        const checkAutoMessages = () => {
          const now = Date.now();
          if (now - autoSendTimestamp > autoSendDelay) {
            const clients = nodes.filter((n) => n.type === NODE_TYPES.CLIENT);
            if (!clients.length) return;

            const { delay, delayVariance, batchSize } = MESSAGE_CONFIG.autoSend;

            for (let i = 0; i < batchSize; i++) {
              setTimeout(() => {
                const source =
                  clients[Math.floor(Math.random() * clients.length)];
                Math.random() < 0.05
                  ? sendFlood(source.id)
                  : sendMessage(source.id);
              }, i * 120);
            }

            autoSendTimestamp = now;
            autoSendDelay = delay + getRandomInt(-delayVariance, delayVariance);
          }
        };

        // --- UI / EVENT FUNCTIONS ---

        const isPortrait = () => {
          return window.matchMedia("(orientation: portrait)").matches;
        };

        const updatePauseButton = () => {
          if (!pauseBtn) pauseBtn = document.getElementById("toggle-pause");

          const config = BUTTON_CONFIGS.find(
            (btn) => btn.id === "toggle-pause",
          );
          if (!config) return;

          const icon = animationRunning
            ? config.icon.pause
            : config.icon.resume;
          const label = animationRunning
            ? config.label.pause
            : config.label.resume;

          const iconSpan = pauseBtn.querySelector(".icon");
          if (iconSpan) {
            iconSpan.textContent = icon;
          }

          [...pauseBtn.childNodes].forEach((node, idx) => {
            if (idx > 0 && node.nodeType === Node.TEXT_NODE) {
              pauseBtn.removeChild(node);
            }
          });

          pauseBtn.appendChild(document.createTextNode(" " + label));
        };

        const togglePause = () => {
          animationRunning = !animationRunning;
          updatePauseButton();
          if (animationRunning) animate(performance.now());
        };

        // Resize canvas to match container with scaling
        const resizeCanvas = () => {
          const container = canvas.parentElement;
          const newWidth = container.offsetWidth;
          const newHeight = container.offsetHeight;

          canvas.width = newWidth * dpr;
          canvas.height = newHeight * dpr;
          canvas.style.width = newWidth + "px";
          canvas.style.height = newHeight + "px";

          ctx.setTransform(1, 0, 0, 1, 0, 0); // reset transforms
          ctx.scale(dpr, dpr);

          if (!initialLayoutDone) {
            baseWidth = newWidth;
            baseHeight = newHeight;
            initialLayoutDone = true;
          } else {
            const widthScaleFactor = newWidth / baseWidth;
            const heightScaleFactor = newHeight / baseHeight;

            if (newWidth / newHeight > baseWidth / baseHeight) {
              targetScaleFactor = heightScaleFactor;
            } else {
              targetScaleFactor = widthScaleFactor;
            }
          }
        };

        const setupEventListeners = () => {
          window.addEventListener("resize", () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
              if (window.devicePixelRatio !== dpr) {
                dpr = window.devicePixelRatio || 1;
              }
              resizeCanvas();
              updateNodeSizes();

              nodes.forEach((node) => {
                const config = getNodeConfig(node.type);
                if (!config) return;
                node.size = config.size;
                node.radius = config.radius;
              });
            }, 150); // Debounce delay in milliseconds
          });

          pauseBtn = document.getElementById("toggle-pause");

          BUTTON_CONFIGS.forEach(({ id, action }) => {
            const button = document.getElementById(id);
            if (button && action) {
              button.addEventListener("pointerdown", (e) => {
                e.preventDefault(); // prevent unintended focus or zoom
                action();
              });
            }
          });

          // Pause/resume animation on hero section visibility change
          if ("IntersectionObserver" in window) {
            const observer = new IntersectionObserver(
              (entries) => {
                entries.forEach((entry) => {
                  if (entry.isIntersecting) {
                    if (!animationRunning) {
                      animationRunning = true;
                      animate(performance.now());
                      updatePauseButton();
                    }
                  } else {
                    if (animationRunning) {
                      animationRunning = false;
                      cancelAnimationFrame(animationFrame);
                    }
                  }
                });
              },
              {
                threshold: 0.01,
              },
            );

            const target = document.querySelector(".hero-section");
            observer.observe(target);
          }
        };

        // Animation loop
        const animate = (timestamp) => {
          if (!animationRunning) return;

          const deltaTime = (timestamp - lastFrameTime) / 1000; // seconds

          if (timestamp - lastFrameTime < MIN_FRAME_DELAY * 0.9) {
            animationFrame = requestAnimationFrame(animate);
            return;
          }
          lastFrameTime = timestamp;

          // Smooth, springy zoom animation
          const scaleDelta = targetScaleFactor - scaleFactor;
          scaleVelocity += scaleDelta * SCALE_SPRING;
          scaleVelocity *= SCALE_DAMPING;
          scaleFactor += scaleVelocity;

          updateMessages(deltaTime);
          updateFloods(deltaTime);
          checkAutoMessages();
          draw();
          animationFrame = requestAnimationFrame(animate);
        };

        // --- INITIALIZATION ---

        const init = () => {
          canvas = document.getElementById("mesh-canvas");
          ctx = canvas.getContext("2d");
          const controlsContainer =
            document.getElementById("controls-container");

          BUTTON_CONFIGS.forEach(({ id, icon, label }) => {
            const [iconSymbol, labelText] = [
              typeof icon === "object" ? icon.pause : icon,
              typeof label === "object" ? label.pause : label,
            ];

            const button = document.createElement("button");
            button.id = id;
            button.innerHTML = `<span class="icon">${iconSymbol}</span> ${labelText}`;
            controlsContainer.appendChild(button);
          });

          resizeCanvas();
          updateNodeSizes();
          initNetwork();
          setupEventListeners();
          animate(performance.now());
        };

        if (document.readyState !== "loading") init();
        else document.addEventListener("DOMContentLoaded", init);
      })();
    </script>
  </body>
</html>
