<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mesh Network Demonstration</title>
    <style>
      :root {
        /* Inland Northwest inspired color palette */
        --bg-color: #f5f3ed;
        --client-color: #4a9fc9;
        --repeater-color: #2d5e82;
        --message-color: #d97762;
        --flood-color: #e6ad3f;
        --text-color: #333333;
        --button-bg: #4a9fc9;
        --button-hover: #2d5e82;
        --button-text: #ffffff;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      #fps-monitor {
        position: fixed;
        bottom: 8px;
        right: 8px;
        background: rgba(0, 0, 0, 0.6);
        color: #0f0;
        font-family: monospace;
        font-size: 12px;
        padding: 4px 8px;
        border-radius: 4px;
        z-index: 9999;
        pointer-events: none;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu,
          Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        background-color: #ffffff;
        color: var(--text-color);
      }

      .hero-section {
        position: relative;
        width: 100%;
        height: 30vh;
        min-height: 250px;
        background-color: var(--bg-color);
        overflow: hidden;
      }

      .hero-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 2;
        padding: 1rem;
      }

      .hero-text-background {
        background-color: rgba(0, 0, 0, 0.6);
        padding: 1.5rem 2rem;
        border-radius: 5px;
        max-width: 90%;
        text-align: center;
      }

      .hero-title {
        font-size: 2.5rem;
        font-weight: 700;
        margin-bottom: 1rem;
        color: white;
      }

      .hero-description {
        font-size: 1.2rem;
        max-width: 600px;
        color: white;
      }

      #mesh-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      .fallback-image {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        text-align: center;
        color: var(--text-color);
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 0.6rem;
        padding: 1rem;
        max-width: 1200px;
        margin: 0 auto;
      }

      .controls button {
        background-color: var(--button-bg);
        color: var(--button-text);
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 500;
        transition: background-color 0.2s;
        display: flex;
        align-items: center;
        gap: 0.4rem;
        touch-action: manipulation; /* disables double-tap zoom */
      }

      .controls button .icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
      }

      .controls button:hover {
        background-color: var(--button-hover);
      }

      .icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: inherit;
        line-height: 1;
        height: auto;
      }

      @media (max-width: 768px) {
        .hero-title {
          font-size: 1.8rem;
        }

        .hero-description {
          font-size: 1rem;
        }

        .controls {
          justify-content: center;
        }

        .controls button {
          font-size: 0.8rem;
          padding: 0.4rem 0.8rem;
        }

        .controls button .icon {
          font-size: 1.2rem;
        }
      }
    </style>
  </head>
  <body>
    <section class="hero-section">
      <div class="hero-overlay">
        <div class="hero-text-background">
          <h1 class="hero-title">Mesh Network Communication</h1>
          <p class="hero-description">
            Visualizing how messages propagate across a distributed network of
            client and repeater nodes.
          </p>
        </div>
      </div>
      <canvas id="mesh-canvas"></canvas>
      <noscript>
        <div class="fallback-image">
          <div>
            <h2>Mesh Network Visualization</h2>
            <p>JavaScript is required to view the mesh network animation.</p>
          </div>
        </div>
      </noscript>
    </section>

    <div class="controls" id="controls-container"></div>

    <script>
      (() => {
        // --- CONSTANTS ---

        const ROOT_STYLES = getComputedStyle(document.documentElement);

        const NODE_TYPES = { CLIENT: "client", REPEATER: "repeater" };

        const DEFAULT_NODE_CONFIGS = {
          [NODE_TYPES.CLIENT]: {
            count: 25,
            mobileCountFactor: 0.6,
            size: 15,
            radius: 12,
            range: 200,
            rangeVariance: 30,
            useGrid: false,
            postPlacement: ensureClientConnectivity,
            color: ROOT_STYLES.getPropertyValue("--client-color").trim(),
          },
          [NODE_TYPES.REPEATER]: {
            count: 10,
            mobileCountFactor: 0.4,
            size: 25,
            radius: 20,
            range: 300,
            rangeVariance: 50,
            useGrid: true,
            color: ROOT_STYLES.getPropertyValue("--repeater-color").trim(),
          },
        };

        const PLACEMENT_ATTEMPTS_MAX = 30;

        const DEFAULT_MESSAGE_CONFIG = {
          types: { DIRECT: "direct", FLOOD: "flood" },
          size: 7,
          pulseGrowth: 15,
          speed: 320, // pixels per second
          maxHops: 5,
          autoSend: {
            delay: 1200, // milliseconds
            delayVariance: 500, // milliseconds
            batchSize: 4, // messages per interval
          },
          color: ROOT_STYLES.getPropertyValue("--message-color").trim(),
        };

        const BUTTON_CONFIGS = [
          {
            id: "send-message",
            icon: "→",
            label: "Send Message",
            action: () => {
              sendMessage();
              setTimeout(sendMessage, 150);
              setTimeout(sendMessage, 300);
            },
          },
          {
            id: "send-flood",
            icon: "➜",
            label: "Send Flood",
            action: () => sendFlood(),
          },
          {
            id: "add-client",
            icon: "＋",
            label: "Add Client",
            action: () => addNode(NODE_TYPES.CLIENT),
          },
          {
            id: "add-repeater",
            icon: "⊕",
            label: "Add Repeater",
            action: () => addNode(NODE_TYPES.REPEATER),
          },
          {
            id: "reset",
            icon: "↻",
            label: "Reset",
            action: () => resetNetwork(),
          },
        ];

        const TARGET_FPS = isMobileDevice() ? 30 : 60;
        const MIN_FRAME_DELAY = 1000 / TARGET_FPS;

        const SCALE_SPRING = 0.1; // spring stiffness
        const SCALE_DAMPING = 0.8; // friction resistance

        const FLOOD_EXPANSION_SPEED = isMobileDevice() ? 100 : 160; // pixels per second
        const DISAPPEARANCE_SPEED = 0.6; // seconds

        const IS_DEBUG_MODE = window.location.search.includes("debug");

        // --- STATE VARIABLES ---

        let canvas;
        let ctx;
        let dpr = window.devicePixelRatio || 1;
        let baseWidth, baseHeight;
        let resizeTimeout;

        let nodes = [];
        let messages = [];
        let floodRings = [];
        let processedFloodIds = new Set();

        let nodeConfigs;
        let minNodeDistance;
        let messageConfig;

        let autoSendTimestamp = Date.now();
        let autoSendDelay = 0;

        let animationRunning = true;
        let initialLayoutDone = false;
        let animationFrame = null;
        let lastFrameTime = 0;

        let scaleFactor = 1;
        let targetScaleFactor = 1;
        let scaleVelocity = 0;

        let fpsDisplay = null;
        let lastDrawTime = 0;
        let drawTimes = [];

        // --- UTILITY FUNCTIONS ---

        function adjustColorBrightness(hex, percent) {
          let r = parseInt(hex.substring(1, 3), 16);
          let g = parseInt(hex.substring(3, 5), 16);
          let b = parseInt(hex.substring(5, 7), 16);

          r = Math.max(0, Math.min(255, r + percent));
          g = Math.max(0, Math.min(255, g + percent));
          b = Math.max(0, Math.min(255, b + percent));

          // Convert back to hex
          return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
        }

        function generateId() {
          return Math.random().toString(36).substr(2, 9);
        }

        function getDistance({ x: x1, y: y1 }, { x: x2, y: y2 }) {
          return Math.hypot(x2 - x1, y2 - y1);
        }

        function getRandomInt(min, max) {
          return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function isMobileDevice() {
          return (
            window.innerWidth <= 768 ||
            (navigator.maxTouchPoints > 0 &&
              /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                navigator.userAgent,
              ))
          );
        }

        // --- CORE SIMULATION FUNCTIONS ---

        function createNode(type) {
          const config = getNodeConfig(type);
          if (!config) return null;

          const { radius, range, rangeVariance, size } = config;

          const node = {
            id: generateId(),
            type,
            x: getRandomInt(radius * 2, baseWidth - radius * 2),
            y: getRandomInt(radius * 2, baseHeight - radius * 2),
            radius,
            range: range + getRandomInt(-rangeVariance, rangeVariance),
            size,
          };

          return node;
        }

        function isTooCloseToOtherNodes(x, y, excludeId = null) {
          return nodes.some(
            (node) =>
              (excludeId === null || node.id !== excludeId) &&
              getDistance({ x, y }, node) < minNodeDistance,
          );
        }

        const placeNodes = (type) => {
          const config = getNodeConfig(type);
          if (!config) return;

          const { count, useGrid, postPlacement } = config;

          let gridCols, gridRows, cellWidth, cellHeight;
          if (useGrid) {
            gridCols = Math.ceil(Math.sqrt(count));
            gridRows = Math.ceil(count / gridCols);
            cellWidth = baseWidth / gridCols;
            cellHeight = baseHeight / gridRows;
          }

          let placed = 0;
          for (let i = 0; i < count; i++) {
            const node = createNode(type);
            let attempts = 0;
            let validPlacement = false;

            while (!validPlacement && attempts < PLACEMENT_ATTEMPTS_MAX) {
              if (useGrid) {
                const row = Math.floor(placed / gridCols);
                const col = placed % gridCols;
                node.x =
                  col * cellWidth + cellWidth * (0.25 + Math.random() * 0.5);
                node.y =
                  row * cellHeight + cellHeight * (0.25 + Math.random() * 0.5);
              } else {
                node.x = getRandomInt(
                  node.radius * 2,
                  baseWidth - node.radius * 2,
                );
                node.y = getRandomInt(
                  node.radius * 2,
                  baseHeight - node.radius * 2,
                );
              }

              validPlacement = !isTooCloseToOtherNodes(node.x, node.y);
              attempts++;
            }

            nodes.push(node);
            placed++;
          }

          if (postPlacement) {
            postPlacement();
          }
        };

        function getNodeConfig(type) {
          const config = nodeConfigs[type];
          if (!config) {
            console.error(`Unknown node type: ${type}`);
            return null;
          }
          return config;
        }

        // Ensure every client can communicate with at least one repeater
        function ensureClientConnectivity() {
          const repeaters = nodes.filter(
            (node) => node.type === NODE_TYPES.REPEATER,
          );

          nodes.forEach((node) => {
            if (node.type === NODE_TYPES.CLIENT) {
              // Check if this client can reach any repeater
              const canReachRepeater = repeaters.some(
                (repeater) =>
                  getDistance(node, repeater) <=
                  Math.max(node.range, repeater.range),
              );

              if (!canReachRepeater && repeaters.length > 0) {
                // Find the closest repeater
                repeaters.sort(
                  (a, b) => getDistance(node, a) - getDistance(node, b),
                );
                const closest = repeaters[0];

                // Calculate a position that's within range but not too close
                const distance = getDistance(node, closest);
                const angle = Math.atan2(
                  node.y - closest.y,
                  node.x - closest.x,
                );
                const targetDistance =
                  Math.min(closest.range, node.range) * 0.9; // 90% of the smaller range

                let newX = closest.x + Math.cos(angle) * targetDistance;
                let newY = closest.y + Math.sin(angle) * targetDistance;

                // Make sure it's within canvas bounds
                newX = Math.max(
                  node.radius * 2,
                  Math.min(newX, baseWidth - node.radius * 2),
                );
                newY = Math.max(
                  node.radius * 2,
                  Math.min(newY, baseHeight - node.radius * 2),
                );

                node.x = newX;
                node.y = newY;
              }
            }
          });
        }

        function getNeighbors(node) {
          return nodes.filter(
            (other) =>
              other.id !== node.id && getDistance(node, other) <= node.range,
          );
        }

        /**
         * Performs a breadth-first search to find the shortest valid route
         * from the source node to the target node, considering wireless range.
         *
         * - Direct client-to-client hops are allowed.
         * - Multi-hop paths (3+ nodes) must use only repeaters as intermediate hops.
         * - Returns a path as an array of node { id, x, y } objects, always including the source.
         * - If no valid route is found, returns a single-element array with only the source.
         *
         * @param {Object} sourceNode - The starting node.
         * @param {Object} targetNode - The destination node.
         * @returns {Array} Array of hops (each with id, x, y).
         */
        function findRoute(sourceNode, targetNode) {
          const visited = new Set();
          const queue = [
            [{ id: sourceNode.id, x: sourceNode.x, y: sourceNode.y }],
          ];

          while (queue.length > 0) {
            const path = queue.shift();
            const last = path[path.length - 1];

            if (last.id === targetNode.id) {
              // Validate intermediate hops (must be repeaters if path length > 2)
              if (
                path.length <= 2 ||
                path.slice(1, -1).every((hop) => {
                  const node = nodes.find((n) => n.id === hop.id);
                  return node && node.type === NODE_TYPES.REPEATER;
                })
              ) {
                return path;
              }
              continue;
            }

            if (visited.has(last.id)) continue;
            visited.add(last.id);

            const currentNode = nodes.find((n) => n.id === last.id);
            if (!currentNode) continue;

            const neighbors = getNeighbors(currentNode).filter(
              (other) => !visited.has(other.id),
            );

            for (const neighbor of neighbors) {
              queue.push([
                ...path,
                { id: neighbor.id, x: neighbor.x, y: neighbor.y },
              ]);
            }
          }

          // No valid route found
          return [{ id: sourceNode.id, x: sourceNode.x, y: sourceNode.y }];
        }

        /**
         * Creates a direct (non-flood) message between two clients.
         * May be single-hop or multi-hop (via repeaters), depending on network topology.
         */
        function createDirectMessage(sourceNode, targetNode) {
          const route = findRoute(sourceNode, targetNode);

          if (
            route.length === 1 || // no valid path
            route.length - 1 > messageConfig.maxHops // too many hops
          ) {
            return null;
          }

          return {
            id: generateId(),
            type: messageConfig.types.DIRECT,
            sourceId: sourceNode.id,
            targetId: targetNode.id,
            x: sourceNode.x,
            y: sourceNode.y,
            size: messageConfig.size,
            route: route,
            currentHopIndex: 0,
            delivered: false,
            progress: 0, // Used for drawing a trail
            trail: [], // Store previous positions for trail effect
            trail_max_length: 10, // Max number of positions to store
          };
        }

        // Create a flood ring (visualization for flood messages)
        function createFloodRing(sourceNode, originalFloodId = null) {
          const floodId = originalFloodId || generateId();
          return {
            id: generateId(),
            floodId: floodId, // Unique ID for this flood event
            sourceId: sourceNode.id,
            x: sourceNode.x,
            y: sourceNode.y,
            radius: 0,
            maxRadius: sourceNode.range,
            expandSpeed: FLOOD_EXPANSION_SPEED,
            opacity: 0.7,
            affectedNodes: new Set(), // Track which nodes have been affected by this flood
          };
        }

        const addNode = (type) => {
          const node = createNode(type);
          let validPlacement = false;
          let attempts = 0;

          while (!validPlacement && attempts < 30) {
            node.x = getRandomInt(node.radius * 2, baseWidth - node.radius * 2);
            node.y = getRandomInt(
              node.radius * 2,
              baseHeight - node.radius * 2,
            );
            validPlacement = !isTooCloseToOtherNodes(node.x, node.y);
            attempts++;
          }

          nodes.push(node);
        };

        function randomClient(excludeId = null) {
          const clients = nodes.filter(
            (n) => n.type === NODE_TYPES.CLIENT && n.id !== excludeId,
          );
          return clients[Math.floor(Math.random() * clients.length)];
        }

        function clientsNearby(sourceNode) {
          return getNeighbors(sourceNode).filter(
            (n) => n.type === NODE_TYPES.CLIENT,
          );
        }

        function clientsBeyondRange(sourceNode) {
          return nodes.filter(
            (n) =>
              n.type === NODE_TYPES.CLIENT &&
              n.id !== sourceNode.id &&
              getDistance(sourceNode, n) > sourceNode.range,
          );
        }

        function tryMultiHopRoute(sourceNode, candidates) {
          for (let i = 0; i < 3; i++) {
            const target =
              candidates[Math.floor(Math.random() * candidates.length)];
            const msg = createDirectMessage(sourceNode, target);
            if (!msg) continue;

            // Prefer longer, visually interesting paths
            if (msg.route.length > 3) return msg;

            // Accept shorter multi-hop (1 repeater) routes 50% of the time,
            // but keep looking in hopes of finding a longer path
            if (msg.route.length > 2 && Math.random() < 0.5) return msg;
          }
          return null;
        }

        function tryFallbackRoute(sourceNode, candidates) {
          for (const target of candidates) {
            const msg = createDirectMessage(sourceNode, target);
            if (msg) return msg;
          }
          return null;
        }

        const sendMessage = (sourceNodeId = null) => {
          const sourceNode = sourceNodeId
            ? nodes.find((n) => n.id === sourceNodeId)
            : randomClient();
          if (!sourceNode) return;

          const directClients = clientsNearby(sourceNode);
          const relayClients = clientsBeyondRange(sourceNode);

          let message = null;

          // Prefer visually interesting multi-hop messages (via repeaters)
          if (relayClients.length > 0 && Math.random() < 0.8) {
            message = tryMultiHopRoute(sourceNode, relayClients);
          }

          // If no multi-hop route selected, try sending to a nearby client directly
          if (!message && directClients.length > 0) {
            const target =
              directClients[Math.floor(Math.random() * directClients.length)];
            message = createDirectMessage(sourceNode, target);
          }

          // As a last fallback, attempt any valid route to a distant client (even short ones)
          if (!message && relayClients.length > 0) {
            message = tryFallbackRoute(sourceNode, relayClients);
          }

          if (message) {
            messages.push(message);
          }
        };

        // Send a flood message
        const sendFlood = (sourceNodeId = null) => {
          const sourceNode = sourceNodeId
            ? nodes.find((n) => n.id === sourceNodeId)
            : randomClient();
          if (!sourceNode) return;

          // Create a unique flood ring from this node and track it
          const floodId = generateId();
          const ring = createFloodRing(sourceNode, floodId);

          processedFloodIds.add(`${floodId}-${sourceNode.id}`);
          floodRings.push(ring);
        };

        const resetNetwork = () => {
          cancelAnimationFrame(animationFrame);
          initNetwork();
          animate(performance.now());
        };

        // Scale simulation parameters based on device size and pixel density
        const applyScaling = () => {
          const sizeFactor = isMobileDevice() ? 0.5 : 1;

          nodeConfigs = {};
          Object.entries(DEFAULT_NODE_CONFIGS).forEach(([type, def]) => {
            const countFactor = isMobileDevice() ? def.mobileCountFactor : 1;

            nodeConfigs[type] = {
              ...def,
              count: Math.floor(def.count * countFactor),
              size: def.size * sizeFactor,
              radius: def.radius * sizeFactor,
              range: def.range * sizeFactor,
              rangeVariance: def.rangeVariance * sizeFactor,
              borderColor: adjustColorBrightness(def.color, -20),
            };
          });

          minNodeDistance = isMobileDevice() ? 40 : 70;

          messageConfig = {
            ...DEFAULT_MESSAGE_CONFIG,
            size: DEFAULT_MESSAGE_CONFIG.size * sizeFactor,
            pulseGrowth: DEFAULT_MESSAGE_CONFIG.pulseGrowth * sizeFactor,
            speed: DEFAULT_MESSAGE_CONFIG.speed * sizeFactor,
          };
        };

        const initNetwork = () => {
          // Reset state
          nodes = [];
          messages = [];
          floodRings = [];
          processedFloodIds = new Set();

          // Place well-distributed repeaters first
          placeNodes(NODE_TYPES.REPEATER);
          placeNodes(NODE_TYPES.CLIENT);
        };

        // --- DRAWING FUNCTIONS ---

        // Draw transmission range for nodes
        const drawNodeRanges = () => {
          nodes.forEach((node) => {
            ctx.beginPath();
            ctx.arc(node.x, node.y, node.range, 0, Math.PI * 2);

            // Different colors for client and repeater ranges
            if (node.type === NODE_TYPES.CLIENT) {
              ctx.strokeStyle = "rgba(74, 159, 201, 0.1)";
            } else {
              ctx.strokeStyle = "rgba(45, 94, 130, 0.1)";
            }

            ctx.lineWidth = 1;
            ctx.stroke();
          });
        };

        // Draw flood rings
        const drawFloodRings = () => {
          floodRings.forEach((ring) => {
            ctx.beginPath();
            ctx.arc(ring.x, ring.y, ring.radius, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(230, 173, 63, ${ring.opacity})`;
            ctx.lineWidth = 2;
            ctx.stroke();
          });
        };

        // Draw message routes (faint lines showing the path)
        const drawMessageRoutes = () => {
          messages.forEach((message) => {
            if (message.type !== messageConfig.types.DIRECT) return;
            if (message.delivered) return; // Don't show routes for delivered messages

            // Draw the complete route
            ctx.beginPath();
            ctx.setLineDash([3, 3]);
            ctx.strokeStyle = "rgba(217, 119, 98, 0.4)";
            ctx.lineWidth = 1;

            const route = message.route;
            ctx.moveTo(route[0].x, route[0].y);

            for (let i = 1; i < route.length; i++) {
              ctx.lineTo(route[i].x, route[i].y);
            }

            ctx.stroke();
            ctx.setLineDash([]); // Reset line dash
          });
        };

        // Draw trails behind messages
        const drawMessageTrails = () => {
          messages.forEach((message) => {
            if (message.type !== messageConfig.types.DIRECT) return;
            if (!message.trail || message.trail.length < 2) return;

            ctx.beginPath();
            const trail = message.trail;
            ctx.moveTo(trail[0].x, trail[0].y);

            for (let i = 1; i < trail.length; i++) {
              ctx.lineTo(trail[i].x, trail[i].y);
            }

            // Fade based on how old the last point is
            const now = performance.now();
            const oldest = trail[0].time;
            const newest = trail[trail.length - 1].time;
            const alpha = Math.min(1, (now - oldest) / (newest - oldest + 1));

            const gradient = ctx.createLinearGradient(
              trail[0].x,
              trail[0].y,
              trail[trail.length - 1].x,
              trail[trail.length - 1].y,
            );
            gradient.addColorStop(0, "rgba(217, 119, 98, 0)");
            gradient.addColorStop(1, "rgba(217, 119, 98, 0.5)");

            ctx.strokeStyle = gradient;
            ctx.lineWidth = 3;
            ctx.stroke();
          });
        };

        const drawHexagon = ({ x, y, size, fillColor, borderColor }) => {
          const numberOfSides = 6;
          const a = (Math.PI * 2) / numberOfSides;

          ctx.beginPath();
          ctx.moveTo(
            x + size * Math.cos(Math.PI / 2),
            y + size * Math.sin(Math.PI / 2),
          );

          for (let i = 1; i <= numberOfSides; i++) {
            const angle = Math.PI / 2 + a * i;
            ctx.lineTo(x + size * Math.cos(angle), y + size * Math.sin(angle));
          }

          ctx.closePath();
          ctx.fillStyle = fillColor;
          ctx.fill();
          ctx.strokeStyle = borderColor;
          ctx.lineWidth = 1.5;
          ctx.stroke();
        };

        const drawNodes = () => {
          nodes.forEach((node) => {
            const config = getNodeConfig(node.type);
            if (!config) return;

            drawHexagon({
              x: node.x,
              y: node.y,
              size: node.size,
              fillColor: config.color,
              borderColor: config.borderColor,
            });
          });
        };

        const drawMessages = () => {
          messages.forEach((message) => {
            if (message.type !== messageConfig.types.DIRECT) return;

            const color = messageConfig.color;

            if (message.delivered) {
              // Draw delivery effect (growing pulse)
              const easedProgress = Math.pow(message.progress, 0.5);

              ctx.beginPath();
              ctx.arc(
                message.x,
                message.y,
                message.size + easedProgress * messageConfig.pulseGrowth,
                0,
                Math.PI * 2,
              );
              ctx.fillStyle = `rgba(217, 119, 98, ${1 - easedProgress})`;
              ctx.fill();
            }

            // Draw message (circle)
            ctx.beginPath();
            ctx.arc(message.x, message.y, message.size, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();

            // Add a white border to make messages more visible
            ctx.strokeStyle = "rgba(255, 255, 255, 0.6)";
            ctx.lineWidth = 1;
            ctx.stroke();
          });
        };

        // Draw all elements on canvas
        const draw = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const scaledWidth = canvas.width / dpr;
          const scaledHeight = canvas.height / dpr;

          // Calculate the center offset to position the network in the middle
          const offsetX = (scaledWidth - baseWidth * scaleFactor) / 2;
          const offsetY = (scaledHeight - baseHeight * scaleFactor) / 2;

          ctx.save();
          ctx.scale(scaleFactor, scaleFactor);
          ctx.translate(Math.max(0, offsetX), Math.max(0, offsetY));

          drawNodeRanges();
          drawFloodRings();
          drawMessageRoutes();
          drawMessageTrails();
          drawNodes();
          drawMessages();

          // Restore original scaling
          ctx.restore();
        };

        // --- SIMULATION UPDATE FUNCTIONS ---

        const updateMessages = (deltaTime) => {
          for (let i = messages.length - 1; i >= 0; i--) {
            const message = messages[i];
            if (message.type !== messageConfig.types.DIRECT) continue;

            if (message.delivered) {
              message.progress += deltaTime / DISAPPEARANCE_SPEED;
              if (message.progress >= 1) {
                messages.splice(i, 1);
              }
              continue;
            }

            // Get current and next points in the route
            const currentHopIndex = message.currentHopIndex;
            const nextHopIndex = currentHopIndex + 1;

            // Check if we've reached the end of the route
            if (nextHopIndex >= message.route.length) {
              message.delivered = true;
              continue;
            }

            const currentPoint = message.route[currentHopIndex];
            const nextPoint = message.route[nextHopIndex];

            const now = performance.now();

            // Add current position to trail
            message.trail.push({ x: message.x, y: message.y, time: now });

            // cap trail by time
            const trailDuration = 0.15 * 1000; // seconds worth of trail

            message.trail = message.trail.filter(
              (p) => now - p.time <= trailDuration,
            );

            // Calculate distance to next hop
            const dx = nextPoint.x - message.x;
            const dy = nextPoint.y - message.y;
            const distanceToNext = Math.sqrt(dx * dx + dy * dy);

            const distance = messageConfig.speed * deltaTime;

            if (distance >= distanceToNext) {
              // Reached next hop
              message.x = nextPoint.x;
              message.y = nextPoint.y;
              message.currentHopIndex = nextHopIndex;

              message.trail = [];

              // If we've reached the final destination, mark as delivered
              if (nextHopIndex === message.route.length - 1) {
                message.delivered = true;
                message.progress = 0;
                continue;
              }
            } else {
              // Move towards next hop
              message.x += (dx / distanceToNext) * distance;
              message.y += (dy / distanceToNext) * distance;
            }
          }
        };

        function checkFloodHit(ring, node) {
          const key = `${ring.floodId}-${node.id}`;
          if (node.id === ring.sourceId || processedFloodIds.has(key))
            return false;

          const dist = getDistance({ x: ring.x, y: ring.y }, node);
          const hit = Math.abs(dist - ring.radius) < node.radius;

          if (hit) {
            processedFloodIds.add(key);
            if (node.type === NODE_TYPES.REPEATER) {
              floodRings.push(createFloodRing(node, ring.floodId));
            }
          }
          return hit;
        }

        function updateFloods(deltaTime) {
          for (let i = floodRings.length - 1; i >= 0; i--) {
            const ring = floodRings[i];
            ring.radius += ring.expandSpeed * deltaTime;
            ring.opacity = 0.7 * (1 - ring.radius / ring.maxRadius);

            nodes.forEach((node) => checkFloodHit(ring, node));

            if (ring.radius >= ring.maxRadius) {
              floodRings.splice(i, 1);
            }
          }
        }

        const updateFPS = (timestamp, cpuMs = 0) => {
          if (!IS_DEBUG_MODE) return;

          if (timestamp - lastDrawTime >= MIN_FRAME_DELAY * 0.9) {
            drawTimes.push(timestamp);
            lastDrawTime = timestamp;

            while (drawTimes.length > 0 && timestamp - drawTimes[0] > 1000) {
              drawTimes.shift();
            }

            const fps = drawTimes.length;
            const cpu = cpuMs.toFixed(1).padStart(5);
            fpsDisplay.textContent = `${fps} FPS | ${cpu} ms`;
          }
        };

        const scheduleAutoMessages = () => {
          const idleCallback =
            window.requestIdleCallback ||
            function (cb) {
              return setTimeout(() => cb({ timeRemaining: () => 0 }), 200);
            };

          idleCallback((deadline) => {
            if (nodes.length && animationRunning) {
              const now = Date.now();
              if (now - autoSendTimestamp > autoSendDelay) {
                const clients = nodes.filter(
                  (n) => n.type === NODE_TYPES.CLIENT,
                );
                if (clients.length) {
                  const { delay, delayVariance, batchSize } =
                    messageConfig.autoSend;

                  for (let i = 0; i < batchSize; i++) {
                    setTimeout(() => {
                      const source =
                        clients[Math.floor(Math.random() * clients.length)];
                      Math.random() < 0.05
                        ? sendFlood(source.id)
                        : sendMessage(source.id);
                    }, i * 120);
                  }

                  autoSendTimestamp = now;
                  autoSendDelay =
                    delay + getRandomInt(-delayVariance, delayVariance);
                }
              }
            }

            // Schedule the next idle callback
            scheduleAutoMessages();
          });
        };

        // --- UI / EVENT FUNCTIONS ---

        const isPortrait = () => {
          return window.matchMedia("(orientation: portrait)").matches;
        };

        // Resize canvas to match container with scaling
        const resizeCanvas = () => {
          const container = canvas.parentElement;
          const newWidth = container.offsetWidth;
          const newHeight = container.offsetHeight;

          canvas.width = newWidth * dpr;
          canvas.height = newHeight * dpr;
          canvas.style.width = newWidth + "px";
          canvas.style.height = newHeight + "px";

          ctx.setTransform(1, 0, 0, 1, 0, 0); // reset transforms
          ctx.scale(dpr, dpr);

          if (!initialLayoutDone) {
            baseWidth = newWidth;
            baseHeight = newHeight;
            initialLayoutDone = true;
          } else {
            const widthScaleFactor = newWidth / baseWidth;
            const heightScaleFactor = newHeight / baseHeight;

            if (newWidth / newHeight > baseWidth / baseHeight) {
              targetScaleFactor = heightScaleFactor;
            } else {
              targetScaleFactor = widthScaleFactor;
            }
          }
        };

        const setupEventListeners = () => {
          window.addEventListener("resize", () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
              if (window.devicePixelRatio !== dpr) {
                dpr = window.devicePixelRatio || 1;
              }
              resizeCanvas();
              applyScaling();

              nodes.forEach((node) => {
                const config = getNodeConfig(node.type);
                if (!config) return;
                node.size = config.size;
                node.radius = config.radius;
              });
            }, 150); // Debounce delay in milliseconds
          });

          BUTTON_CONFIGS.forEach(({ id, action }) => {
            const button = document.getElementById(id);
            if (button && action) {
              button.addEventListener("pointerdown", (e) => {
                e.preventDefault(); // prevent unintended focus or zoom
                action();
              });
            }
          });

          // Pause/resume animation on hero section visibility change
          if ("IntersectionObserver" in window) {
            const observer = new IntersectionObserver(
              (entries) => {
                entries.forEach((entry) => {
                  if (entry.isIntersecting) {
                    if (!animationRunning) {
                      animationRunning = true;
                      animate(performance.now());
                    }
                  } else {
                    if (animationRunning) {
                      animationRunning = false;
                      cancelAnimationFrame(animationFrame);
                    }
                  }
                });
              },
              {
                threshold: 0.01,
              },
            );

            const target = document.querySelector(".hero-section");
            observer.observe(target);
          }
        };

        // Animation loop
        const animate = (timestamp) => {
          if (!animationRunning) return;

          if (timestamp - lastFrameTime < MIN_FRAME_DELAY * 0.9) {
            animationFrame = requestAnimationFrame(animate);
            return;
          }

          const cpuStart = performance.now(); // START timing

          const deltaTime = (timestamp - lastFrameTime) / 1000; // seconds
          lastFrameTime = timestamp;

          // Smooth, springy zoom animation
          const scaleDelta = targetScaleFactor - scaleFactor;
          scaleVelocity += scaleDelta * SCALE_SPRING;
          scaleVelocity *= SCALE_DAMPING;
          scaleFactor += scaleVelocity;

          updateMessages(deltaTime);
          updateFloods(deltaTime);
          draw();

          const cpuDuration = performance.now() - cpuStart; // END timing
          updateFPS(timestamp, cpuDuration);

          animationFrame = requestAnimationFrame(animate);
        };

        // --- INITIALIZATION ---

        const init = () => {
          canvas = document.getElementById("mesh-canvas");
          ctx = canvas.getContext("2d");
          const controlsContainer =
            document.getElementById("controls-container");

          BUTTON_CONFIGS.forEach(({ id, icon, label }) => {
            const [iconSymbol, labelText] = [icon, label];
            const button = document.createElement("button");
            button.id = id;
            button.innerHTML = `<span class="icon">${iconSymbol}</span> ${labelText}`;
            controlsContainer.appendChild(button);
          });

          if (IS_DEBUG_MODE) {
            fpsDisplay = document.createElement("div");
            fpsDisplay.id = "fps-monitor";
            document.body.appendChild(fpsDisplay);
          }

          resizeCanvas();
          applyScaling();
          initNetwork();
          scheduleAutoMessages();
          setupEventListeners();
          animate(performance.now());
        };

        if (document.readyState !== "loading") init();
        else document.addEventListener("DOMContentLoaded", init);
      })();
    </script>
  </body>
</html>
