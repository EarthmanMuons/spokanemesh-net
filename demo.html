<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mesh Network Demonstration</title>
    <style>
      :root {
        /* Inland Northwest inspired color palette */
        --bg-color: #f5f3ed;
        --client-color: #4a9fc9;
        --repeater-color: #2d5e82;
        --message-color: #d97762;
        --message-border: rgba(255, 255, 255, 0.6);
        --flood-color: #e6ad3f;
        --text-color: #333333;
        --button-bg: #4a9fc9;
        --button-hover: #2d5e82;
        --button-text: #ffffff;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      #fps-monitor {
        position: fixed;
        bottom: 8px;
        right: 8px;
        background: rgba(0, 0, 0, 0.6);
        color: #0f0;
        font-family: monospace;
        font-size: 12px;
        padding: 4px 8px;
        border-radius: 4px;
        z-index: 9999;
        pointer-events: none;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu,
          Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        background-color: #ffffff;
        color: var(--text-color);
      }

      .hero-section {
        position: relative;
        width: 100%;
        height: 30vh;
        min-height: 250px;
        background-color: var(--bg-color);
        overflow: hidden;
        user-select: none;
        -webkit-user-select: none;
        touch-action: manipulation;
      }

      .hero-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 2;
        padding: 1rem;
        pointer-events: none;
      }

      .hero-text-background {
        background-color: rgba(0, 0, 0, 0.6);
        padding: 1.5rem 2rem;
        border-radius: 5px;
        max-width: 90%;
        text-align: center;
      }

      .hero-title {
        font-size: 2.5rem;
        font-weight: 700;
        margin-bottom: 1rem;
        color: white;
      }

      .hero-description {
        font-size: 1.2rem;
        max-width: 600px;
        color: white;
      }

      #mesh-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      .fallback-image {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        text-align: center;
        color: var(--text-color);
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 0.6rem;
        padding: 1rem;
        max-width: 1200px;
        margin: 0 auto;
      }

      .controls button {
        background-color: var(--button-bg);
        color: var(--button-text);
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 500;
        transition: background-color 0.2s;
        display: flex;
        align-items: center;
        gap: 0.4rem;
        touch-action: manipulation; /* disables double-tap zoom */
      }

      .controls button .icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
      }

      .controls button:hover {
        background-color: var(--button-hover);
      }

      .icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: inherit;
        line-height: 1;
        height: auto;
      }

      @media (max-width: 768px) {
        .hero-title {
          font-size: 1.8rem;
        }

        .hero-description {
          font-size: 1rem;
        }

        .controls {
          justify-content: center;
        }

        .controls button {
          font-size: 0.8rem;
          padding: 0.4rem 0.8rem;
        }

        .controls button .icon {
          font-size: 1.2rem;
        }
      }
    </style>
  </head>
  <body>
    <section class="hero-section">
      <div class="hero-overlay">
        <div class="hero-text-background">
          <h1 class="hero-title">Mesh Network Communication</h1>
          <p class="hero-description">
            Visualizing how messages propagate across a distributed network of
            client and repeater nodes.
          </p>
        </div>
      </div>
      <canvas id="mesh-canvas"></canvas>
      <noscript>
        <div class="fallback-image">
          <div>
            <h2>Mesh Network Visualization</h2>
            <p>JavaScript is required to view the mesh network animation.</p>
          </div>
        </div>
      </noscript>
    </section>

    <div class="controls" id="controls-container"></div>

    <script>
      (() => {
        // --- CONSTANTS ---

        const ROOT_STYLES = getComputedStyle(document.documentElement);

        const NODE_TYPES = { CLIENT: "client", REPEATER: "repeater" };

        const DEFAULT_NODE_CONFIGS = {
          [NODE_TYPES.CLIENT]: {
            count: 25,
            mobileCountFactor: 0.6,
            size: 15,
            radius: 12,
            range: 160,
            rangeVariance: 60,
            useGrid: false,
            color: ROOT_STYLES.getPropertyValue("--client-color").trim(),
          },
          [NODE_TYPES.REPEATER]: {
            count: 10,
            mobileCountFactor: 0.4,
            size: 25,
            radius: 20,
            range: 300,
            rangeVariance: 50,
            useGrid: true,
            color: ROOT_STYLES.getPropertyValue("--repeater-color").trim(),
          },
        };

        const PLACEMENT_ATTEMPTS_MAX = 30;

        const DEFAULT_MESSAGE_CONFIG = {
          types: { DIRECT: "direct", FLOOD: "flood" },
          size: 7,
          pulseGrowth: 15,
          speed: 320, // pixels per second
          maxHops: 6,
          autoSend: {
            delay: 1200, // milliseconds
            delayVariance: 500, // milliseconds
            batchSize: 4, // messages per interval
          },
          color: ROOT_STYLES.getPropertyValue("--message-color").trim(),
          borderColor: ROOT_STYLES.getPropertyValue("--message-border").trim(),
        };

        const BUTTON_CONFIGS = [
          {
            id: "send-message",
            icon: "→",
            label: "Send Message",
            action: () => {
              sendMessage();
              setTimeout(sendMessage, 150);
              setTimeout(sendMessage, 300);
            },
          },
          {
            id: "send-flood",
            icon: "➜",
            label: "Send Flood",
            action: () => sendFlood(),
          },
          {
            id: "add-client",
            icon: "＋",
            label: "Add Client",
            action: () => addNode(NODE_TYPES.CLIENT),
          },
          {
            id: "add-repeater",
            icon: "⊕",
            label: "Add Repeater",
            action: () => addNode(NODE_TYPES.REPEATER),
          },
          {
            id: "reset",
            icon: "↻",
            label: "Reset",
            action: () => resetNetwork(),
          },
        ];

        const TARGET_FPS = isMobileDevice() ? 30 : 60;
        const MIN_FRAME_DELAY = 1000 / TARGET_FPS;

        const SCALE_SPRING = 0.1; // spring stiffness
        const SCALE_DAMPING = 0.8; // friction resistance

        const FLOOD_COLOR =
          ROOT_STYLES.getPropertyValue("--flood-color").trim();
        const FLOOD_EXPANSION_SPEED = isMobileDevice() ? 120 : 180; // pixels per second
        const DISAPPEARANCE_SPEED = 0.6; // seconds

        const IS_DEBUG_MODE = window.location.search.includes("debug");

        // --- STATE VARIABLES ---

        let canvas;
        let ctx;
        let dpr = window.devicePixelRatio || 1;
        let baseWidth, baseHeight;
        let resizeTimeout;

        let nodes = [];
        let messages = [];
        let messagePool = [];
        let floodRings = [];
        let floodRingPool = [];
        let processedFloodIds = new Set();
        let activeFloodIds = new Set();
        let hoveredNode = null;

        let nodeConfigs;
        let minNodeDistance;
        let messageConfig;

        let autoSendTimestamp = Date.now();
        let autoSendDelay = 0;

        let animationRunning = true;
        let initialLayoutDone = false;
        let animationFrame = null;
        let lastFrameTime = 0;

        let scaleFactor = 1;
        let targetScaleFactor = 1;
        let scaleVelocity = 0;

        let fpsDisplay = null;
        let lastDrawTime = 0;
        let drawTimes = [];

        // --- UTILITY FUNCTIONS ---

        function adjustColorBrightness(hex, percent) {
          let r = parseInt(hex.substring(1, 3), 16);
          let g = parseInt(hex.substring(3, 5), 16);
          let b = parseInt(hex.substring(5, 7), 16);

          r = Math.max(0, Math.min(255, r + percent));
          g = Math.max(0, Math.min(255, g + percent));
          b = Math.max(0, Math.min(255, b + percent));

          // Convert back to hex
          return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
        }

        function generateId() {
          return Math.random().toString(36).substr(2, 9);
        }

        function getDistance({ x: x1, y: y1 }, { x: x2, y: y2 }) {
          return Math.hypot(x2 - x1, y2 - y1);
        }

        function getRandomInt(min, max) {
          return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function hexToRGBA(hex, alpha = 1) {
          const r = parseInt(hex.slice(1, 3), 16);
          const g = parseInt(hex.slice(3, 5), 16);
          const b = parseInt(hex.slice(5, 7), 16);
          return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function isMobileDevice() {
          return (
            window.innerWidth <= 768 ||
            (navigator.maxTouchPoints > 0 &&
              /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                navigator.userAgent,
              ))
          );
        }

        // --- CORE SIMULATION FUNCTIONS ---

        function createNode(type) {
          const config = getNodeConfig(type);
          if (!config) return null;

          const { radius, range, rangeVariance, size, color } = config;

          const node = {
            id: generateId(),
            type,
            x: getRandomInt(radius * 2, baseWidth - radius * 2),
            y: getRandomInt(radius * 2, baseHeight - radius * 2),
            radius,
            range: range + getRandomInt(-rangeVariance, rangeVariance),
            size,
            color,
          };

          return node;
        }

        function isTooClose(x, y) {
          return nodes.some((n) => getDistance({ x, y }, n) < minNodeDistance);
        }

        function placeNodeRandomly(node, useGrid, col, row, cellW, cellH) {
          for (let i = 0; i < PLACEMENT_ATTEMPTS_MAX; i++) {
            if (useGrid) {
              node.x = col * cellW + cellW * (0.25 + Math.random() * 0.5);
              node.y = row * cellH + cellH * (0.25 + Math.random() * 0.5);
            } else {
              node.x = getRandomInt(
                node.radius * 2,
                baseWidth - node.radius * 2,
              );
              node.y = getRandomInt(
                node.radius * 2,
                baseHeight - node.radius * 2,
              );
            }

            if (!isTooClose(node.x, node.y)) return true;
          }
          return false;
        }

        const placeNodes = (type) => {
          const config = getNodeConfig(type);
          if (!config) return;

          const { count, useGrid } = config;

          const gridCols = useGrid ? Math.ceil(Math.sqrt(count)) : 0;
          const gridRows = useGrid ? Math.ceil(count / gridCols) : 0;
          const cellWidth = useGrid ? baseWidth / gridCols : 0;
          const cellHeight = useGrid ? baseHeight / gridRows : 0;

          let placed = 0;
          for (let i = 0; i < count; i++) {
            const node = createNode(type);
            const row = useGrid ? Math.floor(placed / gridCols) : null;
            const col = useGrid ? placed % gridCols : null;

            const success = placeNodeRandomly(
              node,
              useGrid,
              col,
              row,
              cellWidth,
              cellHeight,
            );
            if (success) {
              nodes.push(node);
              placed++;
            }
          }
        };

        function getNodeConfig(type) {
          const config = nodeConfigs[type];
          if (!config) {
            console.error(`Unknown node type: ${type}`);
            return null;
          }
          return config;
        }

        function getNeighbors(node) {
          return nodes.filter(
            (other) =>
              other.id !== node.id && getDistance(node, other) <= node.range,
          );
        }

        /**
         * Performs a breadth-first search to find the shortest valid route
         * from the source node to the target node, considering wireless range.
         *
         * - Direct client-to-client hops are allowed.
         * - Multi-hop paths (3+ nodes) must use only repeaters as intermediate hops.
         * - Returns a path as an array of node { id, x, y } objects, always including the source.
         * - If no valid route is found, returns a single-element array with only the source.
         *
         * @param {Object} sourceNode - The starting node.
         * @param {Object} targetNode - The destination node.
         * @returns {Array} Array of hops (each with id, x, y).
         */
        function findRoute(sourceNode, targetNode) {
          const visited = new Set();
          const queue = [
            [{ id: sourceNode.id, x: sourceNode.x, y: sourceNode.y }],
          ];

          while (queue.length > 0) {
            const path = queue.shift();
            const last = path[path.length - 1];

            if (last.id === targetNode.id) {
              // Validate intermediate hops (must be repeaters if path length > 2)
              if (
                path.length <= 2 ||
                path.slice(1, -1).every((hop) => {
                  const node = nodes.find((n) => n.id === hop.id);
                  return node && node.type === NODE_TYPES.REPEATER;
                })
              ) {
                return path;
              }
              continue;
            }

            if (visited.has(last.id)) continue;
            visited.add(last.id);

            const currentNode = nodes.find((n) => n.id === last.id);
            if (!currentNode) continue;

            const neighbors = getNeighbors(currentNode).filter(
              (other) => !visited.has(other.id),
            );

            for (const neighbor of neighbors) {
              queue.push([
                ...path,
                { id: neighbor.id, x: neighbor.x, y: neighbor.y },
              ]);
            }
          }

          // No valid route found
          return [{ id: sourceNode.id, x: sourceNode.x, y: sourceNode.y }];
        }

        /**
         * Creates a direct (non-flood) message between two clients.
         * May be single-hop or multi-hop (via repeaters), depending on network topology.
         */
        function createDirectMessage(sourceNode, targetNode) {
          const route = findRoute(sourceNode, targetNode);

          if (
            route.length === 1 || // no valid path
            route.length - 1 > messageConfig.maxHops // too many hops
          ) {
            return null;
          }

          let msg = messagePool.pop() || {
            id: "",
            type: messageConfig.types.DIRECT,
            sourceId: "",
            targetId: "",
            x: 0,
            y: 0,
            size: 0,
            route: [],
            currentHopIndex: 0,
            delivered: false,
            progress: 0,
            trail: [],
            trail_max_length: 10,
          };

          Object.assign(msg, {
            id: generateId(),
            type: messageConfig.types.DIRECT,
            sourceId: sourceNode.id,
            targetId: targetNode.id,
            x: sourceNode.x,
            y: sourceNode.y,
            size: messageConfig.size,
            route,
            currentHopIndex: 0,
            delivered: false,
            progress: 0,
            trail: [],
          });

          return msg;
        }

        // Create a flood ring (visualization for flood messages)
        function createFloodRing(sourceNode, originalFloodId = null) {
          const floodId = originalFloodId || generateId();

          let ring = floodRingPool.pop();
          if (!ring) {
            ring = {
              id: "",
              floodId: "",
              sourceId: "",
              x: 0,
              y: 0,
              radius: 0,
              maxRadius: 0,
              expandSpeed: 0,
              opacity: 0,
              affectedNodes: new Set(),
            };
          } else {
            ring.affectedNodes.clear();
          }

          Object.assign(ring, {
            id: generateId(),
            floodId,
            sourceId: sourceNode.id,
            x: sourceNode.x,
            y: sourceNode.y,
            radius: 0,
            maxRadius: sourceNode.range,
            expandSpeed: FLOOD_EXPANSION_SPEED,
            opacity: 0.7,
          });
          activeFloodIds.add(floodId);

          return ring;
        }

        const addNode = (type) => {
          const node = createNode(type);
          const success = placeNodeRandomly(node, false); // no grid for manual adds
          if (success) nodes.push(node);
        };

        function randomClient(excludeId = null) {
          const clients = nodes.filter(
            (n) => n.type === NODE_TYPES.CLIENT && n.id !== excludeId,
          );
          return clients[Math.floor(Math.random() * clients.length)];
        }

        function clientsNearby(sourceNode) {
          return getNeighbors(sourceNode).filter(
            (n) => n.type === NODE_TYPES.CLIENT,
          );
        }

        function clientsBeyondRange(sourceNode) {
          return nodes.filter(
            (n) =>
              n.type === NODE_TYPES.CLIENT &&
              n.id !== sourceNode.id &&
              getDistance(sourceNode, n) > sourceNode.range,
          );
        }

        function tryMultiHopRoute(sourceNode, candidates) {
          for (let i = 0; i < 3; i++) {
            const target =
              candidates[Math.floor(Math.random() * candidates.length)];
            const msg = createDirectMessage(sourceNode, target);
            if (!msg) continue;

            // Prefer longer paths
            if (msg.route.length > 3) return msg;

            // Accept shorter multi-hop (1 repeater) routes 50% of the time,
            // but otherwise keep looking in hopes of finding a longer path
            if (msg.route.length > 2 && Math.random() < 0.5) return msg;
          }
          return null;
        }

        function tryFallbackRoute(sourceNode, candidates) {
          for (const target of candidates) {
            const msg = createDirectMessage(sourceNode, target);
            if (msg) return msg;
          }
          return null;
        }

        function findInterestingRoute(sourceNode) {
          const nearbyClients = clientsNearby(sourceNode);
          const distantClients = clientsBeyondRange(sourceNode);

          // Prefer multi-hop routes (visually interesting, activates repeaters)
          if (distantClients.length > 0 && Math.random() < 0.8) {
            const msg = tryMultiHopRoute(sourceNode, distantClients);
            if (msg) return msg;
          }

          // Otherwise, attempt a simple delivery to a nearby client
          if (nearbyClients.length > 0) {
            const target =
              nearbyClients[Math.floor(Math.random() * nearbyClients.length)];
            const msg = createDirectMessage(sourceNode, target);
            if (msg) return msg;
          }

          // As a last resort, try *any* valid route to a distant client
          if (distantClients.length > 0) {
            const msg = tryFallbackRoute(sourceNode, distantClients);
            if (msg) return msg;
          }

          return null;
        }

        const sendMessage = (sourceNodeId = null) => {
          const sourceNode = sourceNodeId
            ? nodes.find((n) => n.id === sourceNodeId)
            : randomClient();
          if (!sourceNode) return;

          const message = findInterestingRoute(sourceNode);
          if (message) messages.push(message);
        };

        // Send a flood message
        const sendFlood = (sourceNodeId = null) => {
          const sourceNode = sourceNodeId
            ? nodes.find((n) => n.id === sourceNodeId)
            : randomClient();
          if (!sourceNode) return;

          // Create a unique flood ring from this node and track it
          const floodId = generateId();
          const ring = createFloodRing(sourceNode, floodId);

          processedFloodIds.add(`${floodId}-${sourceNode.id}`);
          floodRings.push(ring);
        };

        const resetNetwork = () => {
          cancelAnimationFrame(animationFrame);
          initNetwork();
          animate(performance.now());
        };

        // Scale simulation parameters based on device size and pixel density
        const applyScaling = () => {
          const sizeFactor = isMobileDevice() ? 0.5 : 1;

          nodeConfigs = {};
          Object.entries(DEFAULT_NODE_CONFIGS).forEach(([type, def]) => {
            const countFactor = isMobileDevice() ? def.mobileCountFactor : 1;

            nodeConfigs[type] = {
              ...def,
              count: Math.floor(def.count * countFactor),
              size: def.size * sizeFactor,
              radius: def.radius * sizeFactor,
              range: def.range * sizeFactor,
              rangeVariance: def.rangeVariance * sizeFactor,
              borderColor: adjustColorBrightness(def.color, -20),
            };
          });

          minNodeDistance = isMobileDevice() ? 40 : 70;

          messageConfig = {
            ...DEFAULT_MESSAGE_CONFIG,
            size: DEFAULT_MESSAGE_CONFIG.size * sizeFactor,
            pulseGrowth: DEFAULT_MESSAGE_CONFIG.pulseGrowth * sizeFactor,
            speed: DEFAULT_MESSAGE_CONFIG.speed * sizeFactor,
          };
        };

        const initNetwork = () => {
          // Reset state
          nodes = [];
          messages = [];
          floodRings = [];
          processedFloodIds = new Set();
          activeFloodIds = new Set();

          // Place well-distributed repeaters first
          placeNodes(NODE_TYPES.REPEATER);
          placeNodes(NODE_TYPES.CLIENT);
        };

        // --- DRAWING FUNCTIONS ---

        // Draw transmission range for nodes
        const drawNodeRanges = () => {
          nodes.forEach((node) => {
            ctx.beginPath();
            ctx.arc(node.x, node.y, node.range, 0, Math.PI * 2);

            const isHovered = hoveredNode && node.id === hoveredNode.id;

            ctx.strokeStyle = hexToRGBA(node.color, isHovered ? 0.4 : 0.1);
            ctx.lineWidth = 1;
            ctx.stroke();
          });
        };

        const drawFloodRings = () => {
          floodRings.forEach((ring) => {
            ctx.beginPath();
            ctx.arc(ring.x, ring.y, ring.radius, 0, Math.PI * 2);
            ctx.strokeStyle = hexToRGBA(FLOOD_COLOR, ring.opacity);
            ctx.lineWidth = 2;
            ctx.stroke();
          });
        };

        // Draw message routes (faint lines showing the path)
        const drawMessageRoutes = () => {
          messages.forEach((message) => {
            if (message.type !== messageConfig.types.DIRECT) return;
            if (message.delivered) return;

            ctx.beginPath();
            ctx.setLineDash([3, 3]);
            ctx.strokeStyle = hexToRGBA(messageConfig.color, 0.5);
            ctx.lineWidth = 1;

            const route = message.route;
            ctx.moveTo(route[0].x, route[0].y);

            for (let i = 1; i < route.length; i++) {
              ctx.lineTo(route[i].x, route[i].y);
            }

            ctx.stroke();
            ctx.setLineDash([]); // Reset line dash
          });
        };

        // Draw trails behind messages
        const drawMessageTrails = () => {
          messages.forEach((message) => {
            if (message.type !== messageConfig.types.DIRECT) return;
            if (!message.trail || message.trail.length < 2) return;

            ctx.beginPath();
            const trail = message.trail;
            ctx.moveTo(trail[0].x, trail[0].y);

            for (let i = 1; i < trail.length; i++) {
              ctx.lineTo(trail[i].x, trail[i].y);
            }

            // Fade based on how old the last point is
            const now = performance.now();
            const oldest = trail[0].time;
            const newest = trail[trail.length - 1].time;
            const alpha = Math.min(1, (now - oldest) / (newest - oldest + 1));

            const gradient = ctx.createLinearGradient(
              trail[0].x,
              trail[0].y,
              trail[trail.length - 1].x,
              trail[trail.length - 1].y,
            );
            gradient.addColorStop(0, hexToRGBA(messageConfig.color, 0));
            gradient.addColorStop(1, hexToRGBA(messageConfig.color, 0.5));

            ctx.strokeStyle = gradient;
            ctx.lineWidth = 3;
            ctx.stroke();
          });
        };

        const drawHexagon = ({
          x,
          y,
          size,
          fillColor,
          borderColor,
          lineWidth = 1.5,
        }) => {
          const numberOfSides = 6;
          const a = (Math.PI * 2) / numberOfSides;

          ctx.beginPath();
          ctx.moveTo(
            x + size * Math.cos(Math.PI / 2),
            y + size * Math.sin(Math.PI / 2),
          );

          for (let i = 1; i <= numberOfSides; i++) {
            const angle = Math.PI / 2 + a * i;
            ctx.lineTo(x + size * Math.cos(angle), y + size * Math.sin(angle));
          }

          ctx.closePath();
          ctx.fillStyle = fillColor;
          ctx.fill();
          ctx.strokeStyle = borderColor;
          ctx.lineWidth = lineWidth;
          ctx.stroke();
        };

        const drawNodes = () => {
          nodes.forEach((node) => {
            const config = getNodeConfig(node.type);
            if (!config) return;

            const isHovered = hoveredNode && node.id === hoveredNode.id;

            drawHexagon({
              x: node.x,
              y: node.y,
              size: node.size,
              fillColor: config.color,
              borderColor: config.borderColor,
              lineWidth: isHovered ? 3 : 1.5,
            });
          });
        };

        const drawMessages = () => {
          messages.forEach((message) => {
            if (message.type !== messageConfig.types.DIRECT) return;

            const color = messageConfig.color;

            if (message.delivered) {
              // Draw delivery effect (growing pulse)
              const easedProgress = Math.pow(message.progress, 0.5);

              ctx.beginPath();
              ctx.arc(
                message.x,
                message.y,
                message.size + easedProgress * messageConfig.pulseGrowth,
                0,
                Math.PI * 2,
              );
              ctx.fillStyle = hexToRGBA(messageConfig.color, 1 - easedProgress);
              ctx.fill();
            }

            // Draw message (circle)
            ctx.beginPath();
            ctx.arc(message.x, message.y, message.size, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();

            // Add a white border to make messages more visible
            ctx.strokeStyle = messageConfig.borderColor;
            ctx.lineWidth = 1;
            ctx.stroke();
          });
        };

        // Draw all elements on canvas
        const draw = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const scaledWidth = canvas.width / dpr;
          const scaledHeight = canvas.height / dpr;

          // Calculate the center offset to position the network in the middle
          const offsetX = (scaledWidth - baseWidth * scaleFactor) / 2;
          const offsetY = (scaledHeight - baseHeight * scaleFactor) / 2;

          ctx.save();
          ctx.scale(scaleFactor, scaleFactor);
          ctx.translate(Math.max(0, offsetX), Math.max(0, offsetY));

          drawNodeRanges();
          drawFloodRings();
          drawMessageRoutes();
          drawMessageTrails();
          drawNodes();
          drawMessages();

          // Restore original scaling
          ctx.restore();
        };

        // --- SIMULATION UPDATE FUNCTIONS ---

        function updateDeliveredMessage(message, deltaTime) {
          message.progress += deltaTime / DISAPPEARANCE_SPEED;
          return message.progress >= 1;
        }

        /**
         * Returns a unit (normalized) direction vector pointing from `from` to `to`.
         *
         * The result is an object `{ x, y }` where both components range from -1 to 1.
         * If the points are the same, returns `{ x: 0, y: 0 }`.
         *
         * @param {Object} from - Starting point with { x, y }.
         * @param {Object} to - Destination point with { x, y }.
         * @returns {Object} Normalized direction vector { x, y }.
         */
        function getUnitVector(from, to) {
          const dx = to.x - from.x;
          const dy = to.y - from.y;
          const dist = getDistance(from, to);
          return dist === 0 ? { x: 0, y: 0 } : { x: dx / dist, y: dy / dist };
        }

        function advanceMessage(message, deltaTime) {
          const next = message.route[message.currentHopIndex + 1];
          const now = performance.now();

          message.trail.push({ x: message.x, y: message.y, time: now });

          const trailDuration = 150; // milliseconds of trail to keep
          message.trail = message.trail.filter(
            (p) => now - p.time <= trailDuration,
          );

          const distToNext = getDistance(message, next);
          const moveDist = messageConfig.speed * deltaTime;

          if (moveDist >= distToNext) {
            // Reached next hop
            message.x = next.x;
            message.y = next.y;
            message.currentHopIndex++;
            message.trail = [];

            if (message.currentHopIndex === message.route.length - 1) {
              message.delivered = true;
              message.progress = 0;
            }
          } else {
            // Move toward next hop
            const direction = getUnitVector(message, next);
            message.x += direction.x * moveDist;
            message.y += direction.y * moveDist;
          }
        }

        function updateMessages(deltaTime) {
          for (let i = messages.length - 1; i >= 0; i--) {
            const message = messages[i];
            if (message.type !== messageConfig.types.DIRECT) continue;

            if (message.delivered) {
              if (updateDeliveredMessage(message, deltaTime)) {
                messages.splice(i, 1);
                messagePool.push(message); // recycle
              }
            } else {
              advanceMessage(message, deltaTime);
            }
          }
        }

        function checkFloodHit(ring, node) {
          const key = `${ring.floodId}-${node.id}`;
          if (node.id === ring.sourceId || processedFloodIds.has(key))
            return false;

          const dist = getDistance({ x: ring.x, y: ring.y }, node);
          const hit = Math.abs(dist - ring.radius) < node.radius;

          if (hit) {
            processedFloodIds.add(key);
            if (node.type === NODE_TYPES.REPEATER) {
              floodRings.push(createFloodRing(node, ring.floodId));
            }
          }
          return hit;
        }

        function updateFloods(deltaTime) {
          for (let i = floodRings.length - 1; i >= 0; i--) {
            const ring = floodRings[i];
            ring.radius += ring.expandSpeed * deltaTime;
            ring.opacity = 0.7 * (1 - ring.radius / ring.maxRadius);

            nodes.forEach((node) => checkFloodHit(ring, node));

            if (ring.radius >= ring.maxRadius) {
              const expiredRing = floodRings.splice(i, 1)[0];
              floodRingPool.push(expiredRing); // recycle

              // If this was the last ring for its floodId, clean up
              const floodId = expiredRing.floodId;
              const stillActive = floodRings.some(
                (r) => r.floodId === floodId && r !== expiredRing,
              );

              if (!stillActive) {
                for (const key of processedFloodIds) {
                  if (key.startsWith(floodId + "-")) {
                    processedFloodIds.delete(key);
                  }
                }
                activeFloodIds.delete(floodId);
              }
            }
          }
        }

        const updateFPS = (timestamp, cpuMs = 0) => {
          if (!IS_DEBUG_MODE) return;

          if (timestamp - lastDrawTime >= MIN_FRAME_DELAY * 0.9) {
            drawTimes.push(timestamp);
            lastDrawTime = timestamp;

            while (drawTimes.length > 0 && timestamp - drawTimes[0] > 1000) {
              drawTimes.shift();
            }

            const fps = drawTimes.length;
            const cpu = cpuMs.toFixed(1).padStart(5);
            fpsDisplay.textContent = `${fps} FPS | ${cpu} ms`;
          }
        };

        function maybeSendAutoMessages() {
          const now = Date.now();
          if (now - autoSendTimestamp <= autoSendDelay) return;

          const clients = nodes.filter((n) => n.type === NODE_TYPES.CLIENT);
          if (!clients.length) return;

          const { delay, delayVariance, batchSize } = messageConfig.autoSend;
          for (let i = 0; i < batchSize; i++) {
            setTimeout(() => {
              const source =
                clients[Math.floor(Math.random() * clients.length)];
              Math.random() < 0.05
                ? sendFlood(source.id)
                : sendMessage(source.id);
            }, i * 120);
          }

          autoSendTimestamp = now;
          autoSendDelay = delay + getRandomInt(-delayVariance, delayVariance);
        }

        function scheduleAutoMessages() {
          const idleCallback =
            window.requestIdleCallback ||
            function (cb) {
              return setTimeout(() => cb({ timeRemaining: () => 0 }), 200);
            };

          idleCallback(() => {
            if (nodes.length && animationRunning) maybeSendAutoMessages();
            scheduleAutoMessages(); // schedule the next idle callback
          });
        }

        // --- UI / EVENT FUNCTIONS ---

        // Resize canvas to match container with scaling
        const resizeCanvas = () => {
          const container = canvas.parentElement;
          const newWidth = container.offsetWidth;
          const newHeight = container.offsetHeight;

          canvas.width = newWidth * dpr;
          canvas.height = newHeight * dpr;
          canvas.style.width = newWidth + "px";
          canvas.style.height = newHeight + "px";

          ctx.setTransform(1, 0, 0, 1, 0, 0); // reset transforms
          ctx.scale(dpr, dpr);

          if (!initialLayoutDone) {
            baseWidth = newWidth;
            baseHeight = newHeight;
            initialLayoutDone = true;
          } else {
            const widthScaleFactor = newWidth / baseWidth;
            const heightScaleFactor = newHeight / baseHeight;

            if (newWidth / newHeight > baseWidth / baseHeight) {
              targetScaleFactor = heightScaleFactor;
            } else {
              targetScaleFactor = widthScaleFactor;
            }
          }
        };

        function setupResizeListener() {
          window.addEventListener("resize", () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
              if (window.devicePixelRatio !== dpr) {
                dpr = window.devicePixelRatio || 1;
              }
              resizeCanvas();
              applyScaling();

              nodes.forEach((node) => {
                const config = getNodeConfig(node.type);
                if (!config) return;
                node.size = config.size;
                node.radius = config.radius;
              });
            }, 150);
          });
        }

        function setupVisibilityObserver() {
          if (!("IntersectionObserver" in window)) return;

          const observer = new IntersectionObserver(
            (entries) => {
              entries.forEach((entry) => {
                if (entry.isIntersecting) {
                  if (!animationRunning) {
                    animationRunning = true;
                    animate(performance.now());
                  }
                } else {
                  if (animationRunning) {
                    animationRunning = false;
                    cancelAnimationFrame(animationFrame);
                  }
                }
              });
            },
            { threshold: 0.01 },
          );

          const target = document.querySelector(".hero-section");
          observer.observe(target);
        }

        function setupButtonListeners() {
          BUTTON_CONFIGS.forEach(({ id, action }) => {
            const button = document.getElementById(id);
            if (button && action) {
              button.addEventListener("pointerdown", (e) => {
                e.preventDefault();
                action();
              });
            }
          });
        }

        function setupCanvasHoverListener() {
          canvas.addEventListener("pointermove", (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / scaleFactor;
            const y = (e.clientY - rect.top) / scaleFactor;

            hoveredNode = nodes.find((n) => getDistance(n, { x, y }) <= n.size);

            if (hoveredNode && !animationRunning) {
              draw(); // force one frame
            }
          });

          canvas.addEventListener("pointerleave", () => {
            hoveredNode = null;
          });
        }

        function setupCanvasClickListener() {
          canvas.addEventListener("pointerdown", (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / scaleFactor;
            const y = (e.clientY - rect.top) / scaleFactor;

            const clickedNode = nodes.find(
              (n) => getDistance(n, { x, y }) <= n.size,
            );

            if (clickedNode && clickedNode.type === NODE_TYPES.CLIENT) {
              sendMessage(clickedNode.id);
            }

            hoveredNode = clickedNode;
          });
        }

        function setupEventListeners() {
          setupResizeListener();
          setupVisibilityObserver();
          setupButtonListeners();
          setupCanvasHoverListener();
          setupCanvasClickListener();
        }

        // Animation loop
        const animate = (timestamp) => {
          if (!animationRunning) return;

          if (timestamp - lastFrameTime < MIN_FRAME_DELAY * 0.9) {
            animationFrame = requestAnimationFrame(animate);
            return;
          }

          const cpuStart = performance.now(); // START timing

          const deltaTime = (timestamp - lastFrameTime) / 1000; // seconds
          lastFrameTime = timestamp;

          // Smooth, springy zoom animation
          const scaleDelta = targetScaleFactor - scaleFactor;
          scaleVelocity += scaleDelta * SCALE_SPRING;
          scaleVelocity *= SCALE_DAMPING;
          scaleFactor += scaleVelocity;

          updateMessages(deltaTime);
          updateFloods(deltaTime);
          draw();

          const cpuDuration = performance.now() - cpuStart; // END timing
          updateFPS(timestamp, cpuDuration);

          animationFrame = requestAnimationFrame(animate);
        };

        // --- INITIALIZATION ---

        const init = () => {
          canvas = document.getElementById("mesh-canvas");
          ctx = canvas.getContext("2d");
          const controlsContainer =
            document.getElementById("controls-container");

          BUTTON_CONFIGS.forEach(({ id, icon, label }) => {
            const [iconSymbol, labelText] = [icon, label];
            const button = document.createElement("button");
            button.id = id;
            button.innerHTML = `<span class="icon">${iconSymbol}</span> ${labelText}`;
            controlsContainer.appendChild(button);
          });

          if (IS_DEBUG_MODE) {
            fpsDisplay = document.createElement("div");
            fpsDisplay.id = "fps-monitor";
            document.body.appendChild(fpsDisplay);
          }

          resizeCanvas();
          applyScaling();
          initNetwork();
          scheduleAutoMessages();
          setupEventListeners();
          animate(performance.now());
        };

        if (document.readyState !== "loading") init();
        else document.addEventListener("DOMContentLoaded", init);
      })();
    </script>
  </body>
</html>
