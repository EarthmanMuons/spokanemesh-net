<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mesh Network Demonstration</title>
    <style>
      :root {
        /* Inland Northwest inspired color palette */
        --bg-color: hsl(45, 29%, 95%); /* #f5f3ed */
        --client-color: hsl(200, 54%, 54%); /* #4a9fc9 */
        --client-color-dark: hsl(200, 54%, 44%);
        --repeater-color: hsl(205, 49%, 34%); /* #2d5e82 */
        --repeater-color-dark: hsl(205, 49%, 24%);
        --packet-color: hsl(11, 61%, 62%); /* #d97762 */
        --packet-color-border: hsla(0, 0%, 100%, 0.6); /* #ffffff */
        --flood-color: hsl(40, 77%, 57%); /* #e6ad3f */
        --text-color: hsl(0, 0%, 20%); /* #333333 */
        --button-bg: hsl(200, 54%, 54%); /* #4a9fc9 */
        --button-hover: hsl(205, 49%, 34%); /* #2d5e82 */
        --button-text: hsl(0, 0%, 100%); /* #ffffff */
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      #debug-info {
        position: fixed;
        bottom: 8px;
        right: 8px;
        background: rgba(0, 0, 0, 0.6);
        color: #0f0;
        font-family: monospace;
        font-size: 12px;
        padding: 4px 8px;
        border-radius: 4px;
        z-index: 9999;
        pointer-events: none;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu,
          Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
        background-color: #ffffff;
        color: var(--text-color);
      }

      .hero-section {
        position: relative;
        width: 100%;
        height: 30vh;
        min-height: 250px;
        background-color: var(--bg-color);
        overflow: hidden;
        user-select: none;
        -webkit-user-select: none;
        touch-action: manipulation;
      }

      .hero-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 2;
        padding: 1rem;
        pointer-events: none;
      }

      .hero-text-background {
        background-color: rgba(0, 0, 0, 0.6);
        padding: 1.5rem 2rem;
        border-radius: 5px;
        max-width: 90%;
        text-align: center;
      }

      .hero-title {
        font-size: 2.5rem;
        font-weight: 700;
        margin-bottom: 1rem;
        color: white;
      }

      .hero-description {
        font-size: 1.2rem;
        max-width: 600px;
        color: white;
      }

      #mesh-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
      }

      .fallback-image {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        text-align: center;
        color: var(--text-color);
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 0.6rem;
        padding: 1rem;
        max-width: 1200px;
        margin: 0 auto;
      }

      .controls button {
        background-color: var(--button-bg);
        color: var(--button-text);
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 500;
        transition: background-color 0.2s;
        display: flex;
        align-items: center;
        gap: 0.4rem;
        touch-action: manipulation; /* disables double-tap zoom */
      }

      .controls button .icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
      }

      .controls button:hover {
        background-color: var(--button-hover);
      }

      .icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: inherit;
        line-height: 1;
        height: auto;
      }

      @media (max-width: 768px) {
        .hero-title {
          font-size: 1.8rem;
        }

        .hero-description {
          font-size: 1rem;
        }

        .controls {
          justify-content: center;
        }

        .controls button {
          font-size: 0.8rem;
          padding: 0.4rem 0.8rem;
        }

        .controls button .icon {
          font-size: 1.2rem;
        }
      }
    </style>
  </head>
  <body>
    <section class="hero-section">
      <div class="hero-overlay">
        <div class="hero-text-background">
          <h1 class="hero-title">Mesh Network Communication</h1>
          <p class="hero-description">
            Visualizing how packets propagate across a distributed network of
            client and repeater nodes.
          </p>
        </div>
      </div>
      <canvas id="mesh-canvas"></canvas>
      <noscript>
        <div class="fallback-image">
          <div>
            <h2>Mesh Network Visualization</h2>
            <p>JavaScript is required to view the mesh network animation.</p>
          </div>
        </div>
      </noscript>
    </section>

    <div class="controls" id="controls-container"></div>

    <script>
      (() => {
        // --- CONSTANTS ---

        const ROOT_STYLES = getComputedStyle(document.documentElement);
        const [
          CLIENT_COLOR,
          CLIENT_COLOR_DARK,
          REPEATER_COLOR,
          REPEATER_COLOR_DARK,
          PACKET_COLOR,
          PACKET_COLOR_BORDER,
          FLOOD_COLOR,
        ] = [
          "--client-color",
          "--client-color-dark",
          "--repeater-color",
          "--repeater-color-dark",
          "--packet-color",
          "--packet-color-border",
          "--flood-color",
        ].map((v) => ROOT_STYLES.getPropertyValue(v).trim());

        const NodeType = { CLIENT: "client", REPEATER: "repeater" };

        const DEFAULT_NODE_CONFIGS = {
          [NodeType.CLIENT]: {
            count: 25,
            size: 15,
            radius: 12,
            range: 160,
            rangeVariance: 60,
            useGrid: false,
            color: CLIENT_COLOR,
            borderColor: CLIENT_COLOR_DARK,
          },
          [NodeType.REPEATER]: {
            count: 10,
            size: 25,
            radius: 20,
            range: 300,
            rangeVariance: 50,
            useGrid: true,
            color: REPEATER_COLOR,
            borderColor: REPEATER_COLOR_DARK,
          },
        };

        const DEFAULT_PACKET_CONFIG = {
          size: 7,
          speed: 320, // pixels per second
          maxHops: 6,
          autoDispatch: {
            delay: 1200, // milliseconds
            delayVariance: 500, // milliseconds
            batchSize: 4, // packets per interval
          },
          deliveryPulseSize: 15,
          color: PACKET_COLOR,
          borderColor: PACKET_COLOR_BORDER,
        };

        const RoutingStrategy = {
          DIRECT: "direct", // unicast
          FLOOD: "flood", // broadcast
        };

        const BUTTON_CONFIGS = [
          {
            id: "send-direct",
            icon: "→",
            label: "Send Direct",
            title: "Dispatch multiple unicast packets between client nodes",
            action: () => {
              dispatchPacket({ strategy: RoutingStrategy.DIRECT });
              setTimeout(
                () => dispatchPacket({ strategy: RoutingStrategy.DIRECT }),
                150,
              );
              setTimeout(
                () => dispatchPacket({ strategy: RoutingStrategy.DIRECT }),
                300,
              );
            },
          },
          {
            id: "send-flood",
            icon: "➜",
            label: "Send Flood",
            title: "Dispatch a broadcast packet to nearby nodes",
            action: () => dispatchPacket({ strategy: RoutingStrategy.FLOOD }),
          },
          {
            id: "add-client",
            icon: "＋",
            label: "Add Client",
            title: "End-user node that sends and receives packets",
            action: () => addNode(NodeType.CLIENT),
          },
          {
            id: "add-repeater",
            icon: "⊕",
            label: "Add Repeater",
            title: "Relay node that forwards packets between clients",
            action: () => addNode(NodeType.REPEATER),
          },
          {
            id: "reset",
            icon: "↻",
            label: "Reset",
            title: "Reinitialize the network layout and restart the animation",
            action: () => resetNetwork(),
          },
        ];

        const FPS_TARGET = isMobileDevice() ? 30 : 60;
        const MIN_FRAME_DELAY = 1000 / FPS_TARGET;

        const IS_DEBUG_MODE = window.location.search.includes("debug");

        // --- STATE VARIABLES ---

        let canvas;
        let ctx;
        let dpr = window.devicePixelRatio || 1;
        let simWidth;
        let simHeight;
        let resizeTimeout;

        let nodes = [];
        let packets = [];
        let packetPool = [];
        let floodRings = [];
        let floodRingPool = [];
        let processedFloods = new Set();

        let nodeConfigs;
        let minNodeDistance;
        let hoveredNode = null;

        let packetConfig;
        let floodRingSpeed;
        let nextDispatchAt = Date.now();
        let dispatchCooldown = 0;

        let animationRunning = true;
        let initialLayoutDone = false;
        let animationFrame = null;
        let lastFrameTime = 0;
        let hoverFrame = null;
        let lastDrawTime = 0;
        let drawTimes = [];

        let debugInfoElement = null;

        // --- UTILITY FUNCTIONS ---

        function generateId() {
          return crypto.randomUUID();
        }

        function getDistance({ x: x1, y: y1 }, { x: x2, y: y2 }) {
          return Math.hypot(x2 - x1, y2 - y1);
        }

        function getRandomInt(min, max) {
          return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function hslToHsla(hsl, alpha = 1) {
          return hsl.replace("hsl(", "hsla(").replace(")", `, ${alpha})`);
        }

        function isMobileDevice() {
          return (
            window.innerWidth <= 768 ||
            (navigator.maxTouchPoints > 0 &&
              /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                navigator.userAgent,
              ))
          );
        }

        // --- CORE SIMULATION FUNCTIONS ---

        function createNode(type) {
          const config = getNodeConfig(type);
          if (!config) return null;

          const { radius, range, rangeVariance, size, color } = config;

          const node = {
            id: generateId(),
            type,
            x: getRandomInt(radius * 2, simWidth - radius * 2),
            y: getRandomInt(radius * 2, simHeight - radius * 2),
            radius,
            range: range + getRandomInt(-rangeVariance, rangeVariance),
            size,
            color,
          };

          return node;
        }

        function generateCoords(useGrid, col, row, cellW, cellH, radius) {
          if (useGrid) {
            return {
              x: col * cellW + cellW * (0.25 + Math.random() * 0.5),
              y: row * cellH + cellH * (0.25 + Math.random() * 0.5),
            };
          } else {
            return {
              x: getRandomInt(radius * 2, simWidth - radius * 2),
              y: getRandomInt(radius * 2, simHeight - radius * 2),
            };
          }
        }

        function isTooClose(x, y) {
          return nodes.some((n) => getDistance({ x, y }, n) < minNodeDistance);
        }

        function tryPlaceNode(node, useGrid, col, row, cellW, cellH) {
          // attempt placement up to 30 times
          for (let i = 0; i < 30; i++) {
            const { x, y } = generateCoords(
              useGrid,
              col,
              row,
              cellW,
              cellH,
              node.radius,
            );
            node.x = x;
            node.y = y;

            if (!isTooClose(node.x, node.y)) return true;
          }
          return false;
        }

        const layoutNodes = (type) => {
          const config = getNodeConfig(type);
          if (!config) return;

          const { count, useGrid } = config;

          const gridCols = useGrid ? Math.ceil(Math.sqrt(count)) : 0;
          const gridRows = useGrid ? Math.ceil(count / gridCols) : 0;
          const cellWidth = useGrid ? simWidth / gridCols : 0;
          const cellHeight = useGrid ? simHeight / gridRows : 0;

          let placed = 0;
          for (let i = 0; i < count; i++) {
            const node = createNode(type);
            const row = useGrid ? Math.floor(placed / gridCols) : null;
            const col = useGrid ? placed % gridCols : null;

            const success = tryPlaceNode(
              node,
              useGrid,
              col,
              row,
              cellWidth,
              cellHeight,
            );
            if (success) {
              nodes.push(node);
              placed++;
            }
          }
        };

        function getNodeConfig(type) {
          const config = nodeConfigs[type];
          if (!config) {
            console.error(`Unknown node type: ${type}`);
            return null;
          }
          return config;
        }

        function getNeighborsOf(node) {
          return nodes.filter(
            (other) =>
              other.id !== node.id && getDistance(node, other) <= node.range,
          );
        }

        /**
         * Performs a breadth-first search to find the shortest valid route
         * from the source node to the target node, considering wireless range.
         *
         * - Direct client-to-client hops are allowed.
         * - Multi-hop paths (3+ nodes) must use only repeaters as intermediate hops.
         * - Returns a path as an array of node { id, x, y } objects, always including the source.
         * - If no valid route is found, returns a single-element array with only the source.
         *
         * @param {Object} source - The starting node.
         * @param {Object} target - The destination node.
         * @returns {Array} Array of hops (each with id, x, y).
         */
        function findRoute(source, target) {
          const visited = new Set();
          const queue = [[{ id: source.id, x: source.x, y: source.y }]];

          while (queue.length > 0) {
            const path = queue.shift();
            const last = path[path.length - 1];

            if (last.id === target.id) {
              // Validate intermediate hops (must be repeaters if path length > 2)
              if (
                path.length <= 2 ||
                path.slice(1, -1).every((hop) => {
                  const node = nodes.find((n) => n.id === hop.id);
                  return node && node.type === NodeType.REPEATER;
                })
              ) {
                return path;
              }
              continue;
            }

            if (visited.has(last.id)) continue;
            visited.add(last.id);

            const currentNode = nodes.find((n) => n.id === last.id);
            if (!currentNode) continue;

            const neighbors = getNeighborsOf(currentNode).filter(
              (other) => !visited.has(other.id),
            );

            for (const neighbor of neighbors) {
              queue.push([
                ...path,
                { id: neighbor.id, x: neighbor.x, y: neighbor.y },
              ]);
            }
          }

          // No valid route found
          return [{ id: source.id, x: source.x, y: source.y }];
        }

        /**
         * Creates a direct (non-flood) packet between two clients.
         * May be single-hop or multi-hop (via repeaters), depending on network topology.
         */
        function createDirectPacket(source, target) {
          const route = findRoute(source, target);

          if (
            route.length === 1 || // no valid path
            route.length - 1 > packetConfig.maxHops // too many hops
          ) {
            return null;
          }

          let packet = packetPool.pop();
          if (!packet) {
            packet = {
              id: "",
              strategy: RoutingStrategy.DIRECT,
              sourceId: "",
              targetId: "",
              x: 0,
              y: 0,
              size: 0,
              route: [],
              currentHopIndex: 0,
              delivered: false,
              progress: 0,
              trail: [],
              trail_max_length: 10,
            };
          }

          Object.assign(packet, {
            id: generateId(),
            strategy: RoutingStrategy.DIRECT,
            sourceId: source.id,
            targetId: target.id,
            x: source.x,
            y: source.y,
            size: packetConfig.size,
            route,
            currentHopIndex: 0,
            delivered: false,
            progress: 0,
            trail: [],
          });

          return packet;
        }

        // Create a flood ring (visualization for broadcasts)
        function createFloodRing(source, originalFloodId = null) {
          const floodId = originalFloodId || generateId();

          let ring = floodRingPool.pop();
          if (!ring) {
            ring = {
              id: "",
              floodId: "",
              sourceId: "",
              x: 0,
              y: 0,
              radius: 0,
              maxRadius: 0,
              expandSpeed: 0,
              opacity: 0,
              affectedNodes: new Set(),
            };
          } else {
            ring.affectedNodes.clear();
          }

          Object.assign(ring, {
            id: generateId(),
            floodId,
            sourceId: source.id,
            x: source.x,
            y: source.y,
            radius: 0,
            maxRadius: source.range,
            expandSpeed: floodRingSpeed,
            opacity: 0.7,
          });

          return ring;
        }

        const addNode = (type) => {
          const node = createNode(type);
          const success = tryPlaceNode(node, false); // no grid for manual adds
          if (success) nodes.push(node);
        };

        function pickRandomClient(excludeId = null) {
          const clients = nodes.filter(
            (n) => n.type === NodeType.CLIENT && n.id !== excludeId,
          );
          return clients[Math.floor(Math.random() * clients.length)];
        }

        function getClientsFarFrom(node) {
          return nodes.filter(
            (n) =>
              n.type === NodeType.CLIENT &&
              n.id !== node.id &&
              getDistance(node, n) > node.range,
          );
        }

        function getClientsNearby(node) {
          return getNeighborsOf(node).filter((n) => n.type === NodeType.CLIENT);
        }

        function tryMultiHopRoute(source, candidates) {
          for (let i = 0; i < 3; i++) {
            const target =
              candidates[Math.floor(Math.random() * candidates.length)];
            const packet = createDirectPacket(source, target);
            if (!packet) continue;

            // Prefer longer paths
            if (packet.route.length > 3) return packet;

            // Accept shorter multi-hop (1 repeater) routes 50% of the time,
            // but otherwise keep looking in hopes of finding a longer path
            if (packet.route.length > 2 && Math.random() < 0.5) return packet;
          }
          return null;
        }

        function tryAnyRoute(source, candidates) {
          for (const target of candidates) {
            const packet = createDirectPacket(source, target);
            if (packet) return packet;
          }
          return null;
        }

        function findAestheticRoute(source) {
          const farClients = getClientsFarFrom(source);
          const nearClients = getClientsNearby(source);

          // Prefer multi-hop routes (80% chance)
          if (farClients.length > 0 && Math.random() < 0.8) {
            const packet = tryMultiHopRoute(source, farClients);
            if (packet) return packet;
          }

          // Try direct delivery to a nearby client
          if (nearClients.length > 0) {
            const target =
              nearClients[Math.floor(Math.random() * nearClients.length)];
            const packet = createDirectPacket(source, target);
            if (packet) return packet;
          }

          // Fallback to *any* valid route to a distant client
          if (farClients.length > 0) {
            const packet = tryAnyRoute(source, farClients);
            if (packet) return packet;
          }

          return null;
        }

        function dispatchPacket({ id = null, strategy }) {
          const source = id
            ? nodes.find((n) => n.id === id)
            : pickRandomClient();
          if (!source) return;

          if (strategy === RoutingStrategy.DIRECT) {
            const packet = findAestheticRoute(source);
            if (packet) packets.push(packet);
          } else if (strategy === RoutingStrategy.FLOOD) {
            const floodId = generateId();
            const ring = createFloodRing(source, floodId);
            processedFloods.add(`${floodId}-${source.id}`);
            floodRings.push(ring);
          } else {
            console.warn("Unknown routing strategy:", strategy);
          }
        }

        const resetNetwork = () => {
          cancelAnimationFrame(animationFrame);
          applyScaling();
          initNetwork();
          animate(performance.now());
        };

        function scaleForMobile(value) {
          return isMobileDevice() ? Math.round(value * (2 / 3)) : value;
        }

        // Scale simulation parameters based on device size and pixel density
        const applyScaling = () => {
          nodeConfigs = {};
          Object.entries(DEFAULT_NODE_CONFIGS).forEach(([type, def]) => {
            nodeConfigs[type] = {
              ...def,
              count: scaleForMobile(def.count),
              size: scaleForMobile(def.size),
              radius: scaleForMobile(def.radius),
              range: scaleForMobile(def.range),
              rangeVariance: scaleForMobile(def.rangeVariance),
            };
          });

          packetConfig = {
            ...DEFAULT_PACKET_CONFIG,
            size: scaleForMobile(DEFAULT_PACKET_CONFIG.size),
            deliveryPulseSize: scaleForMobile(
              DEFAULT_PACKET_CONFIG.deliveryPulseSize,
            ),
            speed: scaleForMobile(DEFAULT_PACKET_CONFIG.speed),
          };

          minNodeDistance = scaleForMobile(70);
          floodRingSpeed = scaleForMobile(180);
        };

        function initNetwork(clientCount = null, repeaterCount = null) {
          // Reset simulation state
          nodes = [];
          packets = [];
          packetPool = [];
          floodRings = [];
          floodRingPool = [];
          processedFloods = new Set();
          hoveredNode = null;

          // Use current node config counts unless overrides are provided
          const clientCfg = getNodeConfig(NodeType.CLIENT);
          const repeaterCfg = getNodeConfig(NodeType.REPEATER);

          const clientCountFinal = clientCount ?? clientCfg.count;
          const repeaterCountFinal = repeaterCount ?? repeaterCfg.count;

          clientCfg.count = clientCountFinal;
          repeaterCfg.count = repeaterCountFinal;

          // Place repeaters first to give them the best grid spacing
          layoutNodes(NodeType.REPEATER);
          layoutNodes(NodeType.CLIENT);

          nextDispatchAt = Date.now();
        }

        // --- DRAWING FUNCTIONS ---

        // Draw transmission range for nodes
        const drawNodeRanges = () => {
          nodes.forEach((node) => {
            ctx.beginPath();
            ctx.arc(node.x, node.y, node.range, 0, Math.PI * 2);

            const isHovered = hoveredNode && node.id === hoveredNode.id;

            ctx.strokeStyle = hslToHsla(node.color, isHovered ? 0.4 : 0.1);
            ctx.lineWidth = 1;
            ctx.stroke();
          });
        };

        const drawFloodRings = () => {
          floodRings.forEach((ring) => {
            ctx.beginPath();
            ctx.arc(ring.x, ring.y, ring.radius, 0, Math.PI * 2);
            ctx.strokeStyle = hslToHsla(FLOOD_COLOR, ring.opacity);
            ctx.lineWidth = 2;
            ctx.stroke();
          });
        };

        // Draw packet paths (faint lines showing the route)
        const drawPacketRoutes = () => {
          packets.forEach((packet) => {
            if (packet.strategy !== RoutingStrategy.DIRECT) return;
            if (packet.delivered) return;

            ctx.beginPath();
            ctx.setLineDash([3, 3]);
            ctx.strokeStyle = hslToHsla(packetConfig.color, 0.5);
            ctx.lineWidth = 1;

            const route = packet.route;
            ctx.moveTo(route[0].x, route[0].y);

            for (let i = 1; i < route.length; i++) {
              ctx.lineTo(route[i].x, route[i].y);
            }

            ctx.stroke();
            ctx.setLineDash([]); // Reset line dash
          });
        };

        // Draw trails behind packets
        const drawPacketTrails = () => {
          packets.forEach((packet) => {
            if (packet.strategy !== RoutingStrategy.DIRECT) return;
            if (!packet.trail || packet.trail.length < 2) return;

            ctx.beginPath();
            const trail = packet.trail;
            ctx.moveTo(trail[0].x, trail[0].y);

            for (let i = 1; i < trail.length; i++) {
              ctx.lineTo(trail[i].x, trail[i].y);
            }

            // Fade based on how old the last point is
            const now = performance.now();
            const oldest = trail[0].time;
            const newest = trail[trail.length - 1].time;
            const alpha = Math.min(1, (now - oldest) / (newest - oldest + 1));

            const gradient = ctx.createLinearGradient(
              trail[0].x,
              trail[0].y,
              trail[trail.length - 1].x,
              trail[trail.length - 1].y,
            );
            gradient.addColorStop(0, hslToHsla(packetConfig.color, 0));
            gradient.addColorStop(1, hslToHsla(packetConfig.color, 0.5));

            ctx.strokeStyle = gradient;
            ctx.lineWidth = 3;
            ctx.stroke();
          });
        };

        const drawHexagon = ({
          x,
          y,
          size,
          fillColor,
          borderColor,
          lineWidth = 1.5,
        }) => {
          const numberOfSides = 6;
          const a = (Math.PI * 2) / numberOfSides;

          ctx.beginPath();
          ctx.moveTo(
            x + size * Math.cos(Math.PI / 2),
            y + size * Math.sin(Math.PI / 2),
          );

          for (let i = 1; i <= numberOfSides; i++) {
            const angle = Math.PI / 2 + a * i;
            ctx.lineTo(x + size * Math.cos(angle), y + size * Math.sin(angle));
          }

          ctx.closePath();
          ctx.fillStyle = fillColor;
          ctx.fill();
          ctx.strokeStyle = borderColor;
          ctx.lineWidth = lineWidth;
          ctx.stroke();
        };

        const drawNodes = () => {
          nodes.forEach((node) => {
            const config = getNodeConfig(node.type);
            if (!config) return;

            const isHovered = hoveredNode && node.id === hoveredNode.id;

            drawHexagon({
              x: node.x,
              y: node.y,
              size: node.size,
              fillColor: config.color,
              borderColor: config.borderColor,
              lineWidth: isHovered ? 3 : 1.5,
            });
          });
        };

        const drawPackets = () => {
          packets.forEach((packet) => {
            if (packet.strategy !== RoutingStrategy.DIRECT) return;

            const color = packetConfig.color;

            if (packet.delivered) {
              // Draw delivery effect (growing pulse)
              const easedProgress = Math.pow(packet.progress, 0.5);

              ctx.beginPath();
              ctx.arc(
                packet.x,
                packet.y,
                packet.size + easedProgress * packetConfig.deliveryPulseSize,
                0,
                Math.PI * 2,
              );
              ctx.fillStyle = hslToHsla(packetConfig.color, 1 - easedProgress);
              ctx.fill();
            }

            // Draw packet (circle)
            ctx.beginPath();
            ctx.arc(packet.x, packet.y, packet.size, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();

            // Add a border to make packets more visible
            ctx.strokeStyle = packetConfig.borderColor;
            ctx.lineWidth = 1;
            ctx.stroke();
          });
        };

        // Draw all elements on canvas
        const renderFrame = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const scaledWidth = canvas.width / dpr;
          const scaledHeight = canvas.height / dpr;

          // Calculate the center offset to position the network in the middle
          const offsetX = (scaledWidth - simWidth) / 2;
          const offsetY = (scaledHeight - simHeight) / 2;

          drawNodeRanges();
          drawFloodRings();
          drawPacketRoutes();
          drawPacketTrails();
          drawNodes();
          drawPackets();
        };

        // --- SIMULATION UPDATE FUNCTIONS ---

        function updatePacketDeliveryEffect(packet, deltaTime) {
          const duration = 0.6; // seconds
          packet.progress += deltaTime / duration;
          return packet.progress >= 1;
        }

        /**
         * Returns a unit (normalized) direction vector pointing from `from` to `to`.
         *
         * The result is an object `{ x, y }` where both components range from -1 to 1.
         * If the points are the same, returns `{ x: 0, y: 0 }`.
         *
         * @param {Object} from - Starting point with { x, y }.
         * @param {Object} to - Destination point with { x, y }.
         * @returns {Object} Normalized direction vector { x, y }.
         */
        function getUnitVector(from, to) {
          const dx = to.x - from.x;
          const dy = to.y - from.y;
          const dist = getDistance(from, to);
          return dist === 0 ? { x: 0, y: 0 } : { x: dx / dist, y: dy / dist };
        }

        function movePacketAlongRoute(packet, deltaTime) {
          const next = packet.route[packet.currentHopIndex + 1];
          const now = performance.now();

          packet.trail.push({ x: packet.x, y: packet.y, time: now });

          const trailDuration = 150; // milliseconds of trail to keep
          packet.trail = packet.trail.filter(
            (p) => now - p.time <= trailDuration,
          );

          const distToNext = getDistance(packet, next);
          const moveDist = packetConfig.speed * deltaTime;

          if (moveDist >= distToNext) {
            // Reached next hop
            packet.x = next.x;
            packet.y = next.y;
            packet.currentHopIndex++;
            packet.trail = [];

            if (packet.currentHopIndex === packet.route.length - 1) {
              packet.delivered = true;
              packet.progress = 0;
            }
          } else {
            // Move toward next hop
            const direction = getUnitVector(packet, next);
            packet.x += direction.x * moveDist;
            packet.y += direction.y * moveDist;
          }
        }

        function updatePackets(deltaTime) {
          for (let i = packets.length - 1; i >= 0; i--) {
            const packet = packets[i];
            if (packet.strategy !== RoutingStrategy.DIRECT) continue;

            if (packet.delivered) {
              if (updatePacketDeliveryEffect(packet, deltaTime)) {
                packets.splice(i, 1);
                packetPool.push(packet); // recycle
              }
            } else {
              movePacketAlongRoute(packet, deltaTime);
            }
          }
        }

        function processFloodCollision(ring, node) {
          const key = `${ring.floodId}-${node.id}`;
          if (node.id === ring.sourceId || processedFloods.has(key))
            return false;

          const dist = getDistance({ x: ring.x, y: ring.y }, node);
          const hit = Math.abs(dist - ring.radius) < node.radius;

          if (hit) {
            processedFloods.add(key);
            if (node.type === NodeType.REPEATER) {
              floodRings.push(createFloodRing(node, ring.floodId));
            }
          }
          return hit;
        }

        function updateFloods(deltaTime) {
          for (let i = floodRings.length - 1; i >= 0; i--) {
            const ring = floodRings[i];
            ring.radius += ring.expandSpeed * deltaTime;
            ring.opacity = 0.7 * (1 - ring.radius / ring.maxRadius);

            nodes.forEach((node) => processFloodCollision(ring, node));

            if (ring.radius >= ring.maxRadius) {
              const expiredRing = floodRings.splice(i, 1)[0];
              floodRingPool.push(expiredRing); // recycle

              // If this was the last ring for its floodId, clean up
              const floodId = expiredRing.floodId;
              const stillActive = floodRings.some(
                (r) => r.floodId === floodId && r !== expiredRing,
              );

              if (!stillActive) {
                for (const key of processedFloods) {
                  if (key.startsWith(floodId + "-")) {
                    processedFloods.delete(key);
                  }
                }
              }
            }
          }
        }

        const updateFPS = (timestamp, cpuMs = 0) => {
          if (!IS_DEBUG_MODE) return;

          if (timestamp - lastDrawTime >= MIN_FRAME_DELAY * 0.9) {
            drawTimes.push(timestamp);
            lastDrawTime = timestamp;

            while (drawTimes.length > 0 && timestamp - drawTimes[0] > 1000) {
              drawTimes.shift();
            }

            const fps = drawTimes.length;
            const cpu = cpuMs.toFixed(1).padStart(5);
            debugInfoElement.textContent = `${fps} FPS | ${cpu} ms`;
          }
        };

        function dispatchAutoPackets() {
          const now = Date.now();
          if (now < nextDispatchAt) return;

          const clients = nodes.filter((n) => n.type === NodeType.CLIENT);
          if (!clients.length) return;

          const { delay, delayVariance, batchSize } = packetConfig.autoDispatch;
          for (let i = 0; i < batchSize; i++) {
            setTimeout(() => {
              const source =
                clients[Math.floor(Math.random() * clients.length)];
              const strategy =
                Math.random() < 0.05
                  ? RoutingStrategy.FLOOD
                  : RoutingStrategy.DIRECT;
              dispatchPacket({ id: source.id, strategy });
            }, i * 120);
          }

          dispatchCooldown =
            delay + getRandomInt(-delayVariance, delayVariance);
          nextDispatchAt = now + dispatchCooldown;
        }

        function schedulePacketDispatch() {
          const idleCallback =
            window.requestIdleCallback ||
            function (cb) {
              return setTimeout(() => cb({ timeRemaining: () => 0 }), 200);
            };

          idleCallback(() => {
            if (nodes.length && animationRunning) dispatchAutoPackets();
            schedulePacketDispatch(); // loop
          });
        }

        // --- UI / EVENT FUNCTIONS ---

        // Resize canvas to match container with scaling
        const resizeCanvas = () => {
          const container = canvas.parentElement;
          const newWidth = container.offsetWidth;
          const newHeight = container.offsetHeight;

          canvas.width = newWidth * dpr;
          canvas.height = newHeight * dpr;
          canvas.style.width = newWidth + "px";
          canvas.style.height = newHeight + "px";

          ctx.setTransform(1, 0, 0, 1, 0, 0); // reset transforms
          ctx.scale(dpr, dpr);

          if (!initialLayoutDone) {
            simWidth = newWidth;
            simHeight = newHeight;
            initialLayoutDone = true;
          } else {
            const clientCount = nodes.filter(
              (n) => n.type === NodeType.CLIENT,
            ).length;
            const repeaterCount = nodes.filter(
              (n) => n.type === NodeType.REPEATER,
            ).length;

            // Pause animation and reset cleanly
            animationRunning = false;
            cancelAnimationFrame(animationFrame);

            simWidth = newWidth;
            simHeight = newHeight;

            // Reinitialize with current node counts
            applyScaling();
            initNetwork(clientCount, repeaterCount);

            animationRunning = true;
            animate(performance.now());
          }
        };

        function setupResizeListener() {
          window.addEventListener(
            "resize",
            () => {
              clearTimeout(resizeTimeout);
              resizeTimeout = setTimeout(() => {
                if (window.devicePixelRatio !== dpr) {
                  dpr = window.devicePixelRatio || 1;
                }

                resizeCanvas();
              }, 250);
            },
            { passive: true },
          );
        }

        function setupVisibilityObserver() {
          if (!("IntersectionObserver" in window)) return;

          const observer = new IntersectionObserver(
            (entries) => {
              entries.forEach((entry) => {
                if (entry.isIntersecting) {
                  if (!animationRunning) {
                    animationRunning = true;
                    animate(performance.now());
                  }
                } else {
                  if (animationRunning) {
                    animationRunning = false;
                    cancelAnimationFrame(animationFrame);
                  }
                }
              });
            },
            { threshold: 0.01 },
          );

          const target = document.querySelector(".hero-section");
          observer.observe(target);
        }

        function setupButtonListeners() {
          BUTTON_CONFIGS.forEach(({ id, action }) => {
            const button = document.getElementById(id);
            if (button && action) {
              button.addEventListener("pointerdown", (e) => {
                e.preventDefault();
                action();
              });
            }
          });
        }

        function setupNodeHoverListener() {
          canvas.addEventListener(
            "pointermove",
            (e) => {
              if (hoverFrame) return;

              hoverFrame = requestAnimationFrame(() => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                hoveredNode = nodes.find(
                  (n) => getDistance(n, { x, y }) <= n.size,
                );

                if (hoveredNode && !animationRunning) {
                  draw(); // force one frame
                }

                hoverFrame = null;
              });
            },
            { passive: true },
          );

          canvas.addEventListener(
            "pointerleave",
            () => {
              hoveredNode = null;
            },
            { passive: true },
          );
        }

        function setupNodeClickListener() {
          canvas.addEventListener("pointerdown", (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const clickedNode = nodes.find(
              (n) => getDistance(n, { x, y }) <= n.size,
            );

            if (clickedNode && clickedNode.type === NodeType.CLIENT) {
              dispatchPacket({
                id: clickedNode.id,
                strategy: RoutingStrategy.DIRECT,
              });
            }

            hoveredNode = clickedNode;
          });
        }

        function setupEventListeners() {
          setupResizeListener();
          setupVisibilityObserver();
          setupButtonListeners();
          setupNodeHoverListener();
          setupNodeClickListener();
        }

        // Animation loop
        const animate = (timestamp) => {
          if (!animationRunning) return;

          if (timestamp - lastFrameTime < MIN_FRAME_DELAY * 0.9) {
            animationFrame = requestAnimationFrame(animate);
            return;
          }

          const cpuStart = performance.now(); // START timing

          const deltaTime = (timestamp - lastFrameTime) / 1000; // seconds
          lastFrameTime = timestamp;

          updatePackets(deltaTime);
          updateFloods(deltaTime);
          renderFrame();

          const cpuDuration = performance.now() - cpuStart; // END timing
          updateFPS(timestamp, cpuDuration);

          animationFrame = requestAnimationFrame(animate);
        };

        // --- INITIALIZATION ---

        const init = () => {
          canvas = document.getElementById("mesh-canvas");
          ctx = canvas.getContext("2d");
          const controlsContainer =
            document.getElementById("controls-container");

          BUTTON_CONFIGS.forEach(({ id, icon, label, title }) => {
            const [iconSymbol, labelText] = [icon, label];
            const button = document.createElement("button");
            button.id = id;
            button.innerHTML = `<span class="icon">${iconSymbol}</span> ${labelText}`;
            if (title) button.title = title;
            controlsContainer.appendChild(button);
          });

          if (IS_DEBUG_MODE) {
            debugInfoElement = document.createElement("div");
            debugInfoElement.id = "debug-info";
            document.body.appendChild(debugInfoElement);
          }

          resizeCanvas();
          applyScaling();
          initNetwork();
          schedulePacketDispatch();
          setupEventListeners();
          animate(performance.now());
        };

        if (document.readyState !== "loading") init();
        else document.addEventListener("DOMContentLoaded", init);
      })();
    </script>
  </body>
</html>
